@[TOC

# 一、C语言教程

https://www.runoob.com/cprogramming/c-tutorial.html

## 1. C语言教程

C 语言是一种通用的、面向过程式的计算机程序设计语言。1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。

C 语言是一种广泛使用的计算机语言，它与 Java 编程语言一样普及，二者在现代软件程序员之间都得到广泛使用。

当前最新的 C 语言标准为 C18 ，在它之前的 C 语言标准有 C17、C11...C99 等。

**[现在开始学习 C 编程！](https://www.runoob.com/cprogramming/c-intro.html)**

[C 在线工具](https://www.runoob.com/try/showc.php?filename=helloworld&language=c)

### 1.1 谁适合阅读本教程？

本教程是专门为需要从零开始了解 C 语言的软件程序员打造的。本教程将让您对 C 语言有足够的认识，从而提升您自己的专业知识水平。

### 1.2 阅读本教程前，您需要了解的知识： 

在开始学习本教程之前，您需要对计算机编程术语有基本的了解。对任何一种编程语言有基本的了解将有助于您理解 C 语言编程概念，并有助于加快您的学习进度。

### 1.3 编译/执行 C 程序

#### 实例

```c
#include <stdio.h>
int main()
{
    /* 我的第一个 C 程序 */
    printf("Hello, World! \n");
    return 0;
}
```

**实例解析：**

- 所有的 C 语言程序都需要包含 **main()** 函数。 代码从 **main()** 函数开始执行。
- **/\* ... \*/** 用于注释说明。
- **printf()** 用于格式化输出到屏幕。**printf()** 函数在 **"stdio.h"** 头文件中声明。
- **stdio.h** 是一个头文件 (标准输入输出头文件) , **#include** 是一个预处理命令，用来引入头文件。  当编译器遇到 **printf()** 函数时，如果没有找到 **stdio.h** 头文件，会发生编译错误。
- **return 0;** 语句用于表示退出程序。

### 1.4  笔记

> 运行 **C** 程序，**main(int argc, char \*argv[])** 函数传参，**argc** 为参数个数，**argv** 是字符串数组， 下标从 **0** 开始，第一个存放的是可执行程序的文件名字，然后依次存放传入的参数，举个例子 **HelloWorld.c** ：
>
> ```c
> #include <stdio.h> 
> 
> int main(int argc, char *argv[])
> { 
>     /* 我的第一个 C 程序 */ 
>     printf("可执行程序 %s ,参数个数为[%d], 运行输出：[%s]\n",argv[0],argc,argv[1]); 
>     return 0;
> }
> ```
>
> 编译 **gcc HelloWorld.c**，得到可执行程序 **a.out**，运行程序：
>
> ```shell
> ./a.out Hello,World!
> 可执行程序 ./a.out ,参数个数为[2], 运行输出：[Hello,World!]
> ```



> 当是 **int main()** 时，**main()** 的返回值是 **int** 类型，所以是 **return 0;** 现在 **C** 标准里规定 **main()** 返回值必须为 **int**，所以必须写成是 **int main()**。
>
> ```c
> #include <stdio.h>
> int main(){
>     /* 我的第一个 C 程序 */
>     printf("Hello, World!\n");
>     return 0;
> }
> ```
>
> 当是 **void main()** 时，**main()** 的返回值是空，所以可以不写或者是 **return;** 但这是以前的写法了，现在很少用 **void main()** 了，也不推荐大家这么用。写出来的目的就是给大家提个醒，别犯一些低级错误。
>
> ```c
> #include <stdio.h>
> void main()
> {
>     /* 我的第一个 C 程序 */
>     printf("Hello, World!\n");
>     return ;
> }
> ```

## 2. C 简介 

### 2.1 C 简介

 C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。

在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&R 标准。 

UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。

- 易于学习。
- 结构化语言。
- 它产生高效率的程序。
- 它可以处理底层的活动。
- 它可以在多种计算机平台上编译。

### 2.2 关于 C

- C 语言是为了编写 UNIX 操作系统而被发明的。
- C 语言是以 B 语言为基础的，B 语言大概是在 1970 年被引进的。
- C 语言标准是于 1988 年由美国国家标准协会（ANSI，全称 American National Standard Institute）制定的。
- 截至 1973 年，UNIX 操作系统完全使用 C 语言编写。
- 目前，C 语言是最广泛使用的系统程序设计语言。
- 大多数先进的软件都是使用 C 语言实现的。
- 当今最流行的 Linux 操作系统和 RDBMS（Relational Database Management System：关系数据库管理系统） MySQL 都是使用 C 语言编写的。

### 2.3 为什么要使用 C？

C 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：

- 操作系统
- 语言编译器
- 汇编器
- 文本编辑器
- 打印机
- 网络驱动器
- 现代程序
- 数据库
- 语言解释器
- 实体工具

### 2.4 C 程序

一个 C 语言程序，可以是 3 行，也可以是数百万行，它可以写在一个或多个扩展名为 **".c"** 的文本文件中，例如，*hello.c*。您可以使用 **"vi"**、**"vim"** 或任何其他文本编辑器来编写您的 C 语言程序。

本教程假定您已经知道如何编辑一个文本文件，以及如何在程序文件中编写源代码。

------

###  2.5C11

C11（也被称为C1X）指ISO标准ISO/IEC 9899:2011，是当前最新的C语言标准。在它之前的C语言标准为C99。

#### 新特性

- 对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及<stdalign.h>头文件）。
-  _Noreturn 函数标记，类似于 gcc 的 __attribute__((noreturn))。
-  _Generic 关键字。
-  多线程（Multithreading）支持，包括：
   _Thread_local存储类型标识符，<threads.h>头文件，里面包含了线程的创建和管理函数。
   _Atomic类型修饰符和<stdatomic.h>头文件。
-  增强的Unicode的支持。基于C Unicode技术报告ISO/IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16/UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件<uchar.h>。
-  删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。
-  增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。
-  增加了更多浮点处理宏(宏)。
-  匿名结构体/联合体支持。这个在gcc早已存在，C11将其引入标准。
-  静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。
-  新的 fopen() 模式，("…x")。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。
-  新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。

## 3. C 环境设置 

### 本地环境设置

如果您想要设置 C 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C 编译器。

### 文本编辑器

这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。

文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。

通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C 程序的源文件通常使用扩展名 "**.c**"。

在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。

### C 编译器

写在源文件中的源代码是人类可读的源。它需要"编译"，转为机器语言，这样 CPU 可以按给定指令执行程序。 

C 语言编译器用于把源代码编译成最终的可执行程序。这里假设您已经对编程语言编译器有基本的了解了。 

最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。 

以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。 

#### UNIX/Linux 上的安装

如果您使用的是 **Linux 或 UNIX**，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：

```
$ gcc -v
```

如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：

```
Using built-in specs.
Target: i386-redhat-linux
Configured with: ../configure --prefix=/usr .......
Thread model: posix
gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)
```

如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。

本教程是基于 Linux 编写的，所有给定的实例都已在 Cent OS Linux 系统上编译过。

#### Mac OS 上的安装

如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。

Xcode 目前可从 [developer.apple.com/technologies/tools/](http://developer.apple.com/technologies/tools/) 上下载。

#### Windows 上的安装

为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 [ www.mingw.org](http://www.mingw.org/)，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。

当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。

添加您安装的 MinGW 的 bin 子目录到您的 **PATH** 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。

当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。

### 3.2 笔记

> Win10下使用 vscode 编译 c 语言，安装好 MinGW 后，在里面找到 mingw32-gcc.bin, mingw32-gcc-g++.bin, 以及 mingw32-gdb.bin 第一个是 c 语言文件的编译器，第二个是 c++ 的，第三个是用来调试编译后文件的。然后设置好环境变量，编写好 .c 文件，在 vscode 中打开 .c 文件所在的文件夹（注意是文件夹），然后配置 launch.json 文件如下所示：
>
> ```json
> {
> 
>     "version": "0.2.0",
>     "configurations": [
>         {
>             "name": "(gdb) Launch",
>             "type": "cppdbg",
>             "request": "launch",
>             "program": "${workspaceRoot}/${fileBasenameNoExtension}.exe",
>             "args": [],
>             "stopAtEntry": false,
>             "cwd": "${workspaceRoot}",
>             "environment": [],
>             "externalConsole": true,
>             "MIMode": "gdb",
>             "miDebuggerPath": "C:\\Linux\\MinGW_x86_64\\mingw64\\bin\\gdb.exe",
>             "preLaunchTask": "g++",   //tasks.json里面的名字
>             "setupCommands": [
>                 {
>                     "description": "Enable pretty-printing for gdb",
>                     "text": "-enable-pretty-printing",
>                     "ignoreFailures": true
>                 }
>             ]
>             
>         }
>     ]
> }
> ```
>
> tasks.json文件如下所示：
>
> ```json
> {
> 
>     "version": "2.0.0",
>     "tasks": [
>         {
>             "label": "g++",
>             "type": "shell",
>             "command": "g++",
>             "args": [
>                 "-g", "${file}","-o","${fileBasenameNoExtension}.exe"
>             ],
>             "group":{
>                 "kind": "build",
>                 "isDefault": true
>             }
>         }
> 
>     ]
> }
> ```



> **gcc 进行 c 语言编译分为四个步骤：**
>
> 1.预处理，生成预编译文件（.i 文件）： 
>
> ```shell
> gcc –E hello.c –o hello.i 
> ```
>
> 2.编译，生成汇编代码（.s 文件）： 
>
> ```shell
> gcc –S hello.i –o hello.s
> ```
>
> 3.汇编，生成目标文件（.o 文件）：         
>
> ```shell
> gcc –c hello.s –o hello.o 
> ```
>
> 4.链接，生成可执行文件： 
>
> ```shell
> gcc hello.o –o hello
> ```
>
> 有时候，进行调试，可能会用到某个步骤哦



> ## Windows 环境下使用 GCC 
>
>  MinGw 是 Minimal GNU on Windows 的缩写，允许在 GNU/Linux 和 Windows 平台生成本地的 Windows 程序而不需要第三方运行时库。本文主要介绍 MinGw 的安装和使用。
>
> **(一)安装**
>
> -  1.下载 min-gw 安装程序，链接为：http://sourceforge.net/projects/mingw/files/，下载 mingw-get-setup.exe (86.5 kB) 
>   - [清华大学开源软件镜像站 ](https://mirrors.tuna.tsinghua.edu.cn/) 下载地址为：https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/
> -  2.运行 mingw-get-setup.exe (86.5 kB) ,点击“运行”，continue等，注意记住安装的目录，如 **C:\MinGw**,下面修改环境变量时还会用到。 
> -  3.修改环境变量: 选择计算机—属性---高级系统设置---环境变量，在系统变量中找到 Path 变量，在后面加入  min-gw的安装目录，如 **C:\MinGw\bin**
> - 4.在开始菜单中，点击“运行”，输入 **cmd**,打开命令行:输入 **mingw-get.exe**,如果弹出 MinGw installation  manager 窗口，说明安装正常。此时，关闭 MinGw installation  manager 窗口，否则接下来的步骤会报错
> - 5.在cmd中输入命令 **mingw-get install gcc**,等待一会，gcc 就安装成功了。
>
>  如果想安装 g++,gdb,只要输入命令 **mingw-get install g++** 和 **mingw-get install gdb**
>
>  **(二)使用**
>
> 在 cmd 的当前工作目录写 C 程序 test.c： 
>
> ```c
># include <stdio.h>
> int main()
> {
>  printf("%s\n","hello world");
>  return 0;
>    }
>    ```
> 
> 在 cmd 中输入命令 **gcc test.c** 
>
>  在当前目录下会生成 a.exe 的可执行文件，在 cmd 中输入 a.exe 就可以执行程序了。 
>
>  如果想调试程序，可以输入 gdb a.exe 
>
>  进入 gdb 的功能，使用 gdb 常用的命令就可以调试程序了。



> Windows 环境变量的设置：
>
> （1）将刚刚下载好的文件，解压到C盘根目录下，文件夹名称 MinGw；
>
> （2）计算机——>(右键)属性——>高级系统设置——>环境变量——>系统变量，选中Path点击编辑，将MicGw文件下的bin目录路径复制出来，我这里是
>
> C:\MinGW\bin，将路径复制到 Path 中，点击确定；注意点目录前后的分号，一定要有并且必须是英文半角。
>
> （3）同上，新建一个系统变量 lib，对应 MicGw 下的lib 文件夹；新建一个系统变量 include，对应 MicGw 下的 include 文件夹；
>
> 到此为止，我们就算是搭建好C语言开发的基本环境了；

## 4. C 程序结构 

在我们学习 C 语言的基本构建块之前，让我们先来看看一个最小的 C 程序结构，在接下来的章节中可以以此作为参考。

### 4.1 C Hello World 实例

C 程序主要包括以下部分：

- 预处理器指令
- 函数
- 变量
- 语句 & 表达式
- 注释 

让我们看一段简单的代码，可以输出单词 "Hello World"： 

#### 实例

```c
#include <stdio.h>
 
int main()
{
   /* 我的第一个 C 程序 */
   printf("Hello, World! \n");
   
   return 0;
}
```

接下来我们讲解一下上面这段程序：

1. 程序的第一行 *#include* 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。
2. 下一行 *int main()* 是主函数，程序从这里开始执行。
3. 下一行 /*...*/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。
4. 下一行 *printf(...)* 是 C 中另一个可用的函数，会在屏幕上显示消息 "Hello, World!"。
5. 下一行 **return 0;** 终止 main() 函数，并返回值 0。

### 4.2 编译 & 执行 C 程序

接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：

1. 打开一个文本编辑器，添加上述代码。
2. 保存文件为 *hello.c*。
3. 打开命令提示符，进入到保存文件所在的目录。
4. 键入 *gcc hello.c*，输入回车，编译代码。
5. 如果代码中没有错误，命令提示符会跳到下一行，并生成 *a.out* 可执行文件。
6. 现在，键入 *a.out* 来执行程序。
7. 您可以看到屏幕上显示 *"Hello World"*。

```shell
$ gcc hello.c
$ ./a.out
Hello, World!
```

请确保您的路径中已包含 gcc 编译器，并确保在包含源文件 hello.c 的目录中运行它。 

如果是多个 c 代码的源码文件，编译方法如下：

```shell
$ gcc test1.c test2.c -o main.out
$ ./main.out
```

test1.c 与 test2.c 是两个源代码文件。

### 4.3 笔记

> **gcc** 命令如果不指定目标文件名时默认生成的可执行文件名为 **a.out(linux)** 或 **a.exe(windows)**。
>
> 可用 **gcc [源文件名] -o [目标文件名]** 来指定目标文件路径及文件名。
>
> 例如，**windows** 系统上，**gcc hello.c -o target/hello** 会在 **target** 目录下生成 **hello.exe** 文件(Linux 系统生成 hello 可执行文件)，**target** 目录必须已存在，**[源文件名] 和 -o [目标文件名]** 的顺序可互换， **gcc -o target/hello hello.c** 依然有效。



> 因编译器的原因，生成的 **.exe** 文件打开时会一闪而过，从而观察不到其运行的结果，这是因为 **main()** 函数结束时，DOS 窗口会自动关闭。为了避免这个问题可在 **return 0;** 前加入 **system("pause");** 语句。
>
> ```c
> #include <stdio.h>
> #include <stdlib.h> 
> int main()
> {
>    /* 我的第一个 C 程序 */
>    printf("Hello, World! \n");
>    system("pause");      //暂停函数，请按任意键继续...
>    return 0;
> }
> ```
>
> 使用 **gcc hello.c -o hello**  命令时，可不添加目标路径，则 **gcc** 即在当前工作目录自动生成 **hello.exe** 文件。 
>
>  
>
> 如果不想使用 system("pause")函数，可以直接使用cmd运行编译的可执行文件： 

## 5. C 基本语法 

我们已经看过 C 程序的基本结构，这将有助于我们理解 C 语言的其他基本的构建块。

### 5.1 C 的令牌（Token） 

C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：

```c
printf("Hello, World! \n"); 
```

这五个令牌分别是： 

```c
printf
(
"Hello, World! \n"
)
; 
```

#### 分号 ; 

在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。 

例如，下面是两个不同的语句： 

```
printf("Hello, World! \n");
return 0; 
```

#### 注释 c

**C 语言有两种注释方式：** 

```c
// 单行注释
```

以 **//** 开始的单行注释，这种注释可以单独占一行。 

```c
/* 单行注释 */
/* 
 多行注释
 多行注释
 多行注释
 */
```

 **/\* \*/**  这种格式的注释可以单行或多行。 

您不能在注释内嵌套注释，注释也不能出现在字符串或字符值中。

### 5.2 标识符

C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。  

C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是**区分大小写**的编程语言。因此，在 C 中，*Manpower* 和 *manpower* 是两个不同的标识符。下面列出几个有效的标识符：

```
mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
```

#### 关键字

下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。

| 关键字   | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| auto     | 声明自动变量                                                 |
| break    | 跳出当前循环                                                 |
| case     | 开关语句分支                                                 |
| char     | 声明字符型变量或函数返回值类型                               |
| const    | 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 |
| continue | 结束当前循环，开始下一轮循环                                 |
| default  | 开关语句中的"其它"分支                                       |
| do       | 循环语句的循环体                                             |
| double   | 声明双精度浮点型变量或函数返回值类型                         |
| else     | 条件语句否定分支（与 if 连用）                               |
| enum     | 声明枚举类型                                                 |
| extern   | 声明变量或函数是在其它文件或本文件的其他位置定义             |
| float    | 声明浮点型变量或函数返回值类型                               |
| for      | 一种循环语句                                                 |
| goto     | 无条件跳转语句                                               |
| if       | 条件语句                                                     |
| int      | 声明整型变量或函数                                           |
| long     | 声明长整型变量或函数返回值类型                               |
| register | 声明寄存器变量                                               |
| return   | 子程序返回语句（可以带参数，也可不带参数）                   |
| short    | 声明短整型变量或函数                                         |
| signed   | 声明有符号类型变量或函数                                     |
| sizeof   | 计算数据类型或变量长度（即所占字节数）                       |
| static   | 声明静态变量                                                 |
| struct   | 声明结构体类型                                               |
| switch   | 用于开关语句                                                 |
| typedef  | 用以给数据类型取别名                                         |
| unsigned | 声明无符号类型变量或函数                                     |
| union    | 声明共用体类型                                               |
| void     | 声明函数无返回值或无参数，声明无类型指针                     |
| volatile | 说明变量在程序执行中可被隐含地改变                           |
| while    | 循环语句的循环条件                                           |

#### C99 新增关键字

| `_Bool` | `_Complex` | `_Imaginary` | `inline` | `restrict` |
| ------- | ---------- | ------------ | -------- | ---------- |
|         |            |              |          |            |

#### C11 新增关键字  

| `_Alignas`       | `_Alignof`      | `_Atomic` | `_Generic` | `_Noreturn` |
| ---------------- | --------------- | --------- | ---------- | ----------- |
| `_Static_assert` | `_Thread_local` |           |            |             |

### 5.3 C 中的空格

只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。

在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中： 

```c
int age;
```

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：

```c
fruit = apples + oranges;   // 获取水果的总数
```

fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。

### 5.4 笔记

> **C关键字：**
>
> 按年份起始：
>
> - **auto    break   case    char    const     continue  default   do** 
>
> - **double  else    enum    extern  float      for       goto     if** 
>
> - **int          long       register  return   short          signed      sizeof      static** 
>
> - **struct  switch   typedef  union   unsigned  void       volatile  while**
>
> 1999年12月16日，ISO推出了C99标准，该标准新增了5个C语言关键字：
>
> - inline   restrict   _Bool  _Complex   _Imaginary
>
> 2011年12月8日，ISO发布C语言的新标准C11，该标准新增了7个C语言关键字：
>
> - _Alignas  _Alignof  _Atomic  _Static_assert  _Noreturn  _Thread_local  _Generic  



> **C 语言有两种注释方式：**
>
> - （1）以 **//** 开始的单行注释，这种注释可以单独占一行，也可以出现在一行中其他内容的右侧，注意这种注释不能跨行。若注释内容一行内写不下可以在下一行重新用 **//** ，继续写注释。 
>
> - （2）以 **/\*** 开始，以 ***/** 结束的块式注释。这种注释可以包含多行内容。编译系统在发现一个 **/\*** 后，会开始找注释结束符 ***/**，把两者间的内容作为注释。
>
>   应注意的是在字符串中的和都不作为注释的开始。而是作为字符串的一部分。如：
>
>   ```c
>   printf("//how do you do!\n");
>   
>   或
>   
>   printf("/*how do you do!*/\n);
>   ```
>
>   输出分别是：**//how do you do！**和 **/\*how do you do!\*/**

## 6. C 数据类型 

在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。

C 中的类型可分为以下几种：

| 序号 | 类型与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **基本类型：** 它们是算术类型，包括两种类型：整数类型和浮点类型。 |
| 2    | **枚举类型：** 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 |
| 3    | **void 类型：** 类型说明符 *void* 表明没有可用的值。         |
| 4    | **派生类型：** 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。 |

数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。在本章节接下来的部分我们将介绍基本类型，其他几种类型会在后边几个章节中进行讲解。

### 6.1 整数类型 

下表列出了关于标准整数类型的存储大小和值范围的细节：

| 类型           | 存储大小    | 值范围                                               |
| :------------- | :---------- | :--------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

> 注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。

为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 **sizeof** 运算符。表达式 *sizeof(type)* 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小： 

```c
#include <stdio.h>
#include <limits.h>
 
int main()
{
   printf("int 存储大小 : %lu \n", sizeof(int));
   
   return 0;
} 
```

**%lu** 为 32 位无符号整数，详细说明查看 [C 库函数 - printf()](https://www.runoob.com/cprogramming/c-function-printf.html)。

当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：

```
int 存储大小 : 4 
```

### 6.2 浮点类型 

下表列出了关于标准浮点类型的存储大小、值范围和精度的细节： 

| 类型        | 存储大小 | 值范围                 | 精度      |
| :---------- | :------- | :--------------------- | :-------- |
| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |
| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |

头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值： 

```c
#include <stdio.h>
#include <float.h>
 
int main()
{
   printf("float 存储最大字节数 : %lu \n", sizeof(float));
   printf("float 最小值: %E\n", FLT_MIN );
   printf("float 最大值: %E\n", FLT_MAX );
   printf("精度值: %d\n", FLT_DIG );
   
   return 0;
}
```

**%E** 为以指数形式输出单、双精度实数，详细说明查看 [C 库函数 - printf()](https://www.runoob.com/cprogramming/c-function-printf.html)。

当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：

```
float 存储最大字节数 : 4 
float 最小值: 1.175494E-38
float 最大值: 3.402823E+38
精度值: 6
```

### 6.3 void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下： 

| 序号 | 类型与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **函数返回为空** C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 **void exit (int status);** |
| 2    | **函数参数为空** C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 **int rand(void);** |
| 3    | **指针指向 void** 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 **void \*malloc( size_t size );** 返回指向 void 的指针，可以转换为任何数据类型。 |

如果现在您还是无法完全理解 void 类型，不用太担心，在后续的章节中我们将会详细讲解这些概念。

### 6.4 笔记

> 常用基本数据类型占用空间（64位机器为例）
>
> -  char ：  1个字节  
> -  int     ：4个字节 
> -  float：4个字节 
> -  double：8个字节 
>
> 基本类型书写
>
>  整数
>
> - 默认为10进制 ，10 ，20。 
> -  以0开头为8进制，045，021。 
> - 以0b开头为2进制，0b11101101。 
> - 以0x开头为16进制，0x21458adf。 
>
> **小数**
>
> 单精度常量：2.3f 。
>
> 双精度常量：2.3，默认为双精度。
>
> **字符型常量**
>
> 用英文单引号括起来，只保存一个字符'a'、'b' 、'*' ，还有转义字符 '\n' 、'\t'。
>
> **字符串常量**
>
> 用英文的双引号引起来 可以保存多个字符："abc"。

> 1、数据类型转换：C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型；在 C 语言中也可以对数据类型进行强制转换；
>
> 2、自动转换规则： 
>
> -  a）浮点数赋给整型，该浮点数小数被舍去；
> -  b）整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中； 
>
> 3、强制类型转换形式: **(类型说明符)(表达式)**

## 7. C 变量 

变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：

| **类型** | **描述**                                                     |
| -------- | ------------------------------------------------------------ |
| char     | 通常是一个字节（八位）。这是一个整数类型。                   |
| int      | 对机器而言，整数是最自然的大小。                             |
| float    | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 |
| double   | 双精度浮点值。双精度是1位符号，11位指数，52位小数。          |
| void     | 表示类型的缺失。                                             |

C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等，这将会在后续的章节中进行讲解，本章节我们先讲解基本变量类型。

### C 中的变量定义

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： 

```c
type variable_list; 
```

在这里，**type** 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明： 

```c
int    i, j, k;
char   c, ch;
float  f, salary;
double d; 
```

行 **int    i, j, k;** 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。 

变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示： 

```c
type variable_name = value; 
```

下面列举几个实例： 

```c
extern int d = 3, f = 5;    // d 和 f 的声明与初始化
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
```

不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。

### C 中的变量声明

变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

变量的声明有两种情况： 

- 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。 
- 2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。 
- 除非有extern关键字，否则都是变量的定义。

```c
extern int i; //声明，不是定义
int i;        //声明，也是定义
```

#### 实例

尝试下面的实例，其中，变量在头部就已经被声明，但是定义与初始化在主函数内：

```c
#include <stdio.h>
 
// 函数外定义变量 x 和 y
int x;
int y;
int addtwonum()
{
    // 函数内声明变量 x 和 y 为外部变量
    extern int x;
    extern int y;
    // 给外部变量（全局变量）x 和 y 赋值
    x = 1;
    y = 2;
    return x+y;
}
 
int main()
{
    int result;
    // 调用函数 addtwonum
    result = addtwonum();
    
    printf("result 为: %d",result);
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果： 

```
result 为: 3
```

如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。

- addtwonum.c 文件代码

```c
#include <stdio.h>
/*外部变量声明*/
extern int x ;
extern int y ;
int addtwonum()
{
    return x+y;
}
```

- test.c 文件代码：

```c
#include <stdio.h>
  
/*定义两个全局变量*/
int x=1;
int y=2;
int addtwonum();
int main(void)
{
    int result;
    result = addtwonum();
    printf("result 为: %d\n",result);
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```shell
$ gcc addtwonum.c test.c -o main
$ ./main
result 为: 3
```

### C 中的左值（Lvalues）和右值（Rvalues）

C 中有两种类型的表达式：

1. **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
2. **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：

```
int g = 20;
```

但是下面这个就不是一个有效的语句，会生成编译时错误：

```
10 = 20;
```

### 7.4 笔记

> ```c
> extern int a;     // 声明一个全局变量 a
> 
> int a;            // 定义一个全局变量 a
> 
> extern int a =0;  // 定义一个全局变量 a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间
> 
> int a =0;         //定义一个全局变量 a，并给初值
> ```
>
>  声明之后你不能直接使用这个变量，需要定义之后才能使用。 
>
>  第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。 
>
>  糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是 int a 还是 int a=0 都只能出现一次，而那个 extern int a 可以出现很多次。 
>
>  当你要引用一个全局变量的时候，你就要声明 extern int a 这时候 extern 不能省略，因为省略了，就变成 int a 这是一个定义，不是声明。



> **变量的内存寻址(与系统有关)**
>
> (1)内存寻址由大到小，优先分配内存地址比较大的字节给变量，所以说变量越先定义，内存地址就越大（栈区：从高到底生长）。 如下面代码，先定义变量 a,再定义变量 b,打印出 a 的地址是 0x7fff5fbff828,b 的值是 0x7fff5fbff824。a 的地址比 b 的地址大 4 字节。
>
> (2)变量地址的获取方式：& 变量名。
>
> (3)输出地址的方式：%p。
>
> ```c
> #include <stdio.h>  
>  
> int main()   
> {  
>       
>     int a;  
>     int b;  
>   
>     printf("a的地址是%p\nb的地址是%p\n",&a,&b);  
>     return 0;  
>      
> }   
> ```
>
> (4)一个变量一定要先初始化才可以使用，因为 c 语言中默认一个没有初始化的变量值是一个不可知的很大值。如下面所示，a 没有初始化，打印出 a 的值是 1606422582。 
>
> ```c
> #include <stdio.h>  
>   
> int main()   
> {  
>       
>     int a;  
>   
>     printf("a的值是%d\n",a);  
>     return 0;  
>      
> }  
> ```
>
> ------
>
>  第一点和第四点有些小伙伴运行结果可能有差异：



> 在最新的 C 语言标准(C99)解决了布尔类型的问题。
>
> C99 提供了 _Bool 型，所以布尔类型可以声明为 _Bool flag。
>
> _Bool 依然仍是整数类型，但与一般整型不同的是，_Bool 变量只能赋值为 0 或 1，非 0 的值都会被存储为 1。
>
> C99还提供了一个头文件 <stdbool.h> 定义了 bool 代表 _Bool，true 代表 1，false 代表 0。只要导入 stdbool.h ，就能非常方便的操作布尔类型了。
>
> ```c
> //导入 stdbool.h 来使用布尔类型
> #include <stdbool.h>
> #include <stdio.h>
> 
> //计算n!,n的值在main中定义
> int main(void)
> {
>     int n = 10;    //计算叠乘数
>     int sum = 1; //用来存放叠乘的结果
>     bool flag = false;    //叠乘标记
>     
>     int num = n;    //循环次数
>     while( !flag )
>     {
>         sum = sum * (num--);
>         //当num=1时结束循环
>         if( num == 1)
>         {
>             flag = true;
>         }
>     }
>     printf ("%d的叠乘值为 %d \n", n, sum);
>     return 0;
> }
> ```



> **全局变量和局部变量在内存中的区别**
>
> 全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。
>
> C语言经过编译之后将内存分为以下几个区域：
>
> - （1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。 
> - （2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。 
> - （3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。 
> -  （4）文字常量区：存放常量字符串。程序结束后由系统释放。 
> -  （5）程序代码区：存放程序的二进制代码。  
>
> 显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。 
>
> 有兴趣的读者可以运行下面的程序，分析一下运行结果。
>
> ```c
> #include <stdio.h>
> #include <stdlib.h>
> int k1 = 1;
> int k2;
> static int k3 = 2;
> static int k4;
> int main( )
> {  staticint m1=2, m2;
>     inti=1;
>     char*p;
>     charstr[10] = "hello";
>     char*q = "hello";
>     p= (char *)malloc( 100 );
>     free(p);
>     printf("栈区-变量地址  i：%p\n", &i);
>     printf("                p：%p\n", &p);
>     printf("              str：%p\n", str);
>     printf("                q：%p\n", &q);
>     printf("堆区地址-动态申请：%p\n", p);
>     printf("全局外部有初值 k1：%p\n", &k1);
>     printf("    外部无初值 k2：%p\n", &k2);
>     printf("静态外部有初值 k3：%p\n", &k3);
>     printf("    外静无初值 k4：%p\n", &k4);
>     printf("  内静态有初值 m1：%p\n", &m1);
>     printf("  内静态无初值 m2：%p\n", &m2);
>     printf("文字常量地址    ：%p, %s\n",q, q);
>     printf("程序区地址      ：%p\n",&main);
>     return0;
> }
> ```



> **变量定义：**用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。
>
> 变量声明：用于向程序表明变量的类型和名字。
>
> 定义也是声明，extern 声明不是定义。
>
> **定义也是声明：**当定义变量时我们声明了它的类型和名字。 
>
> **extern 声明不是定义：**通过使用 extern 关键字声明变量名而不定义它。 
>
> **[注意]**  
>
> 变量在使用前就要被定义或者声明。 
>
> 在一个程序中，变量只能定义一次，却可以声明多次。 
>
> 定义分配存储空间，而声明不会。

## 8. C 常量 

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。

**常量**就像是常规的变量，只不过常量的值在定义后不能进行修改。

### 1.整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

下面列举几个整数常量的实例：

```c
212         /* 合法的 */
215u        /* 合法的 */
0xFeeL      /* 合法的 */
078         /* 非法的：8 不是八进制的数字 */
032UU       /* 非法的：不能重复后缀 */
```

以下是各种类型的整数常量的实例：

```c
85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
```

### 2.浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

下面列举几个浮点常量的实例：

```c
3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
```

### 3.字符常量

字符常量是括在单引号中，例如，'x' 可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

| 转义序列   | 含义                       |
| ---------- | -------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警报铃声                   |
| \b         | 退格键                     |
| \f         | 换页符                     |
| \n         | 换行符                     |
| \r         | 回车                       |
| \t         | 水平制表符                 |
| \v         | 垂直制表符                 |
| \ooo       | 一到三位的八进制数         |
| \xhh . . . | 一个或多个数字的十六进制数 |

下面的实例显示了一些转义序列字符：

```c
#include <stdio.h>
 
int main()
{
   printf("Hello\tWorld\n\n");
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Hello   World
```

### 4.字符串常量

字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用空格做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。

```c
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
```

### 5.定义常量

在 C 中，有两种简单的定义常量的方式：

1. 使用 **#define** 预处理器。
2. 使用 **const** 关键字。

#### #define 预处理器

下面是使用 #define 预处理器定义常量的形式：

```c
#define identifier value
```

具体请看下面的实例：

```c
#include <stdio.h>
 
#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'
 
int main()
{
 
   int area;  
  
   area = LENGTH * WIDTH;
   printf("value of area : %d", area);
   printf("%c", NEWLINE);
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
value of area : 50
```

#### const 关键字

您可以使用 **const** 前缀声明指定类型的常量，如下所示：

```c
const type variable = value;
```

具体请看下面的实例：

```c
#include <stdio.h>
 
int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   printf("value of area : %d", area);
   printf("%c", NEWLINE);
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
value of area : 50
```

请注意，把常量定义为大写字母形式，是一个很好的编程实践。

### 6.笔记

> **#define** 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 **#define** 不为宏名分配内存，而 **const** 也不为常量分配内存，怎么回事呢，其实 **const** 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！

> 反斜杠(**\**) 开头是叫转义序列(Escape Sequence)。
>
> **\ooo** 是对用三位八进制数转义表示任意字符的形象化描述。  
>
> 比如 **char ch = '\101';** 等价于 **char ch = 0101;** (以0开头的表示八进制）。 
>
> **\xhh**  里面是 x 是固定的，表示十六进制(hexadecimal)，h 也表示十六进制。 
>
> 举例，**char ch = '\x41';** 就是用十六进制来表示，它与前面的 **\101** 是等价的。 
>
> 可用如下代码证明它们等价：
>
> ```
> #include <stdio.h>
>   
> int main(){
>     printf("%c,%c,%c,%c", 0101, '\101', '\x41', 'A');
>     return 0;
> }
> ```

> 在 C 语言中，单引号与双引号是有很大区别的。
>
> 在 C 语言中没有专门的字符串类型，因此双引号内的字符串会被存储到一个数组中，这个字符串代表指向这个数组起始字符的指针； 
>
> 而单引号中的内容是一个 char 类型，是一个字符，这个字符对应的是 ASCII 表中的序列值。

> **const** 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。
>
> **define** 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。
>
> ##  1、两者的区别
>
> **(1) 编译器处理方式不同**
>
> - \#define 宏是在预处理阶段展开。
> -  const 常量是编译运行阶段使用。
>
> **(2) 类型和安全检查不同**
>
> -  \#define 宏没有类型，不做任何类型检查，仅仅是展开。
> -  const 常量有具体的类型，在编译阶段会执行类型检查。
>
> **(3) 存储方式不同**
>
> - \#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
> - const常量会在内存中分配(可以是堆中也可以是栈中)。
>
> **(4) const 可以节省空间，避免不必要的内存分配。 例如：**
>
> ```
> #define NUM 3.14159 //常量宏
> const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......
> double i = Num; //此时为Pi分配内存，以后不再分配！
> double I= NUM; //编译期间进行宏替换，分配内存
> double j = Num; //没有内存分配
> double J = NUM; //再进行宏替换，又一次分配内存！ 
> ```
>
> const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。
>
> **(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。**
>
> **(6) 宏替换只作替换，不做计算，不做表达式求解;**
>
> 宏预编译时就替换了，程序运行时，并不分配内存。

## 9. C 存储类 

存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：

- auto
- register
- static
- extern

### 1. auto 存储类

**auto** 存储类是所有局部变量默认的存储类。

```c
{
   int mount;
   auto int month;
}
```

上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。

### 2. register 存储类

**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

```c
{
   register int  miles;
}
```

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

### 3. static 存储类

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

以下实例演示了 static 修饰全局变量和局部变量的应用：

```c
#include <stdio.h>
 
/* 函数声明 */
void func1(void);
 
static int count=10;        /* 全局变量 - static 是默认的 */
 
int main()
{
  while (count--) 
  {
      func1();
  }
  return 0;
}
 
void func1(void)
{
/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次
 * 每次调用函数 'func1' 'thingy' 值不会被重置。
 */                
  static int thingy=5;
  thingy++;
  printf(" thingy 为 %d ， count 为 %d\n", thingy, count);
}
```

实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。

可能您现在还无法理解这个实例，因为我已经使用了函数和全局变量，这两个概念目前为止还没进行讲解。即使您现在不能完全理解，也没有关系，后续的章节我们会详细讲解。当上面的代码被编译和执行时，它会产生下列结果：

```
 thingy 为 6 ， count 为 9
 thingy 为 7 ， count 为 8
 thingy 为 8 ， count 为 7
 thingy 为 9 ， count 为 6
 thingy 为 10 ， count 为 5
 thingy 为 11 ， count 为 4
 thingy 为 12 ， count 为 3
 thingy 为 13 ， count 为 2
 thingy 为 14 ， count 为 1
 thingy 为 15 ， count 为 0
```

### 4. extern 存储类

**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 **extern** 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

**第一个文件：main.c**

```c
#include <stdio.h>
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
```



**第二个文件：support.c**

```c
#include <stdio.h>
 
extern int count;
 
void write_extern(void)
{
   printf("count is %d\n", count);
}
```



在这里，第二个文件中的 *extern* 关键字用于声明已经在第一个文件 main.c 中定义的 *count*。现在 ，编译这两个文件，如下所示：

```shell
 $ gcc main.c support.c
```

这会产生 **a.out** 可执行程序，当程序被执行时，它会产生下列结果：

```
count is 5
```



### 5. 笔记

> **auto** 是局部变量的默认存储类, 限定变量只能在函数内部使用；
>
> **register** 代表了寄存器变量，不在内存中使用；
>
> **static**是全局变量的默认存储类,表示变量在程序生命周期内可见；
>
> **extern** 表示全局变量，即对程序内所有文件可见，类似于Java中的public关键字；



> ## C 语言中全局变量、局部变量、静态全局变量、静态局部变量的区别 
>
> **从作用域看：** 
>
> 1、全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。 
>
> 2、静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。 
>
> 3、局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。 
>
> 4、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
>
>  
>
> **从分配内存空间看：**
>
> 1、全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间 
>
> 2、全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
>
> -  1)静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
> -  2)变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。 
>
> 从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。
>
> 
>
> **Tips:** 
>
> -  A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度； 
> -  B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； 
> -  C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见； 
> -  D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带"内部存储器"功能的的函数) 
> -  E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

> **静态全局变量与普通全局变量的区别：**
>
>  全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。
>
>  全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式，这两者在存储方式上并无不同。
>
> 这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。

## 10. C 运算符 

## 11. C 判断 

## 12. C 循环 

## 13. C 函数 

## 14. C 作用域规则 

## 15.C 数组 

## 16. C enum(枚举)

枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。

枚举语法定义格式为：

```c
enum　枚举名　{枚举元素1,枚举元素2,……};
```

接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：

```c
#define MON  1
#define TUE  2
#define WED  3
#define THU  4
#define FRI  5
#define SAT  6
#define SUN  7
```

这个看起来代码量就比较多，接下来我们看看使用枚举的方式：

```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

这样看起来是不是更简洁了。

**注意：**第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。

> 可以在定义枚举类型时改变枚举元素的值：
>
> ```c
> enum season {spring, summer=3, autumn, winter};
> ```
>
> 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5

### 枚举变量的定义

前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。

我们可以通过以下三种方式来定义枚举变量

**1、先定义枚举类型，再定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```

**2、定义枚举类型的同时定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**3、省略枚举名称，直接定义枚举变量**

```
enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

```c

```





\#include <stdio.h>  enum DAY {      MON=1, TUE, WED, THU, FRI, SAT, SUN };  int main() {    enum DAY day;    day = WED;    printf("%d",day);    return 0; }

以上实例输出结果为：

```
3
```

 在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。

不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。

以下实例使用 for 来遍历枚举的元素：

```c

```



\#include <stdio.h>  enum DAY {      MON=1, TUE, WED, THU, FRI, SAT, SUN } day; int main() {    // 遍历枚举元素    for (day = MON; day <= SUN; day++) {        printf("枚举元素：%d \n", day);    } }

以上实例输出结果为：

```
枚举元素：1 
枚举元素：2 
枚举元素：3 
枚举元素：4 
枚举元素：5 
枚举元素：6 
枚举元素：7
```

以下枚举类型不连续，这种枚举无法遍历。

```
enum
{
    ENUM_0,
    ENUM_10 = 10,
    ENUM_11
};
```

枚举在 switch 中的使用：

## 实例

\#include <stdio.h> #include <stdlib.h> int main() {     enum color { red=1, green, blue };     enum  color favorite_color;     /* 用户输入数字来选择颜色 */    printf("请输入你喜欢的颜色: (1. red, 2. green, 3. blue): ");    scanf("%d", &favorite_color);     /* 输出结果 */    switch (favorite_color)    {    case red:        printf("你喜欢的颜色是红色");        break;    case green:        printf("你喜欢的颜色是绿色");        break;    case blue:        printf("你喜欢的颜色是蓝色");        break;    default:        printf("你没有选择你喜欢的颜色");    }     return 0; }

以上实例输出结果为：

```
请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1
你喜欢的颜色是红色
```

### 将整数转换为枚举

以下实例将整数转换为枚举：

## 实例

\#include <stdio.h> #include <stdlib.h>  int main() {     enum day    {        saturday,        sunday,        monday,        tuesday,        wednesday,        thursday,        friday    } workday;     int a = 1;    enum day weekend;    weekend = ( enum day ) a;  //类型转换    //weekend = a; //错误    printf("weekend:%d",weekend);    return 0; }

以上实例输出结果为：

```
weekend:1
```



## 17. C 指针 

## C 函数指针与回调函数

## C 字符串 

## C 结构体 

## C 共用体 

## C 位域 

## C typedef 

## C 输入 & 输出 

## C 文件读写 

## C 预处理器 

## C 头文件 

## C 强制类型转换 

## C 错误处理 

## C 递归 

## C 可变参数 

## C 内存管理 

## C 命令行参数 

## C 排序算法

## C 语言实例 

# 二、C 经典100例 





# 三、C 标准库

## C 标准库 - 参考手册 

## C 标准库 - <assert.h> 

## C 标准库 - <ctype.h> 

## C 标准库 - <errno.h> 

## C 标准库 - <float.h> 

## C 标准库 - <limits.h> 

## C 标准库 - <locale.h> 

## C 标准库 - <math.h> 

## C 标准库 - <setjmp.h> 

## C 标准库 - <signal.h> 

## C 标准库 - <stdarg.h> 

## C 标准库 - <stddef.h> 

## C 标准库 - <stdio.h> 

## C 标准库 - <stdlib.h> 

## C 标准库 - <string.h> 

## C 标准库 - <time.h>