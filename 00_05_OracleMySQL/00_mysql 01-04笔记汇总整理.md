# 1.为什么要学习数据库

    市面上99%的软件都会用到数据库
    
    查询、增、删、改、创表删表等操作
# 2.Oracle数据库

## 2.1 登录

```sql
数据库启动关闭    
    以oracle用户登录linux

    sqlplus / as sysdba
        以数据库管理员的方式登录oracle数据库 ，默认用户名是sys
    sql>  startup 
        启动数据库实例  （在sqlplus中执行）
        实例：oracle的一组服务

    sql>  shutdown   
        关闭数据库实例
    exit  退出sqlplus
数据库监听服务启动和关闭

    lsnrctl start
        启动数据库的监听服务
        如果不启动监听服务，oracle远程没有办法连接上的

    lsnrctl stop
        关闭数据库监听服务

    lsnrctl status
        查看监听服务的状态
修改scott用户密码
    必须要oracle的管理员权限去修改
    sqlplus / as sysdba 
    sql> alter user scott identified by "123456" ;

登录scott用户

    sqlplus 用户名/密码
        本地登录
        sqlplus scott/11

    sqlplus 用户名/密码@//服务器ip/实例名(orcl)
        远端登录

    sqlplus scott/11@//192.168.177.233/orcl

查看scott用户方案所拥有的表
    使用scott用户登陆之后
    select * from tab;
```

## 2.2 简单查询：

```sql
select * 
from tableName;

select 列名1 as "别名1",列名2,表达式.... 
from 表名
```



```sql
查询emp表的所有数据  select * from emp;

设置行宽 
	set linesize 140;

设置页高 
	set pagesize 50;

查询员工号，姓名，月薪，奖金，年薪，年收入 并修改列名为中文
    select 
    	empno as "工 号",
    	ename as 姓名,
    	sal 月薪,
    	comm 奖金 ,
    	sal*13 年薪, 
    	sal*13 + nvl(comm,0)  年收入
    from emp;

小结：
    1 sql查询可以按照列名来查询
    2 可以使用表达式作为列名，数据库会自动计算出每一列每一行表达式的值
    3 可以对列起别名

nvl 函数：nvl(f1,f2)
	如果参数1(表达式)为null，则返回参数2

null 数据类型 
	做任何的数值运算结果都为null

查看员工表所有部门编号并去除重复
    select distinct deptno 
    from emp;
说明：
	distinct 的作用：就是去除重复的行

计算表达式3+2
    select 3+2 
    from dual
说明：
	dual是一张虚表，我们可以从这张表里边去计算表达式
```

## 2.3 单条件查询：

```sql
select ...
from ...
where cond

查询10号部门的员工信息
    select * 
    from emp 
    where deptno = 10;

查询员工KING的信息
    select * 
    from emp 
    where ename = 'KING';

注意：数据中的字符串是大小写敏感的

单引号和双引号的说明：
    数据中的字符串，使用单引号
    单引号用于数据的字符串
    双引号用于数据库对象名 ，表名 列名 ...

查询薪水不等于1250的员工信息
大于      小于      不等于       等于
> >=     <  <=      !=  <>      =
    select * 
    from emp 
    where sal <> 1250;

查询入职日期为1981年11月17日的员工信息
    日期的比较可以直接使用字符串来比较，数据库会自动做一个隐式的转换
        select * 
        from emp 
        where hiredate = '1981-11-17';
    ORA-01861: 文字与格式字符串不匹配
    当用字符串跟日期进行比较的时候，注意日期格式
    
    查询当前会话的环境变量
    select * 
    from v$nls_parameters;    
      
    select * 
    from emp 
    where hiredate = '17-11月-81'
    
    修改当前会话的时间日期格式字符串
    alter session 
    set NLS_DATE_FORMAT='yyyy-mm-dd' 
```

## ed 命令

```sql
    sqlplus 中 使用 ed 命令，打开一个编辑器，用来编辑上一条执行过的sql语句
    修改这条语句（最后不要使用分号），换行之后添加一个单独的 / 表示结束  ，保存退出，然后敲入/回车执行上一条指令
```



## 2.4 多条件查询：

```sql
        与       或       非
    C   &&       ||       !
    sql and      or       not

查询10号部门中月薪为1300的员工
    select * 
    from emp 
    where deptno=10 and sal =1300

查询部门号是10或者20的员工信息
    select * 
    from emp 
    where deptno = 10 or deptno = 20

    select * 
    from emp
    where deptno in (10,20)

查询部门不是10和20的员工信息
    select * 
    from emp
    where deptno not in (10,20)

查询工资介于1000到2000之间的员工
    select *
    from emp
    where sal >=1000 and sal <=2000

    select *
    from emp
    where sal between 1000 and 2000
    -- between and 是一个闭区间

查询1981年2月（含2月）到82年2月（不含2月）入职的员工信息
    1981-2-1   1982-1-31

    select * 
    from emp
    where hiredate between '1981-02-01' and '1982-01-31'

查询没有奖金的员工信息
    select * 
    from emp
    where comm = null

    结论：
        null做任何逻辑运算，结果都为假

	-- 用下面这个
    select *
    from emp
    where comm is null

查询有奖金的员工信息
    select *
    from emp
    where comm is not null
```

## 2.5 模糊查询

```sql
每次掉线之后重新连接之后都要设置行宽页高的问题
配置 C:\app\itcast\product\11.2.0\client_1\sqlplus\admin\glogin.sql
        每次登录sqlplus之后都会马上执行的一些指令
```




```sql
select ...
from ..
where 列名 like '模式字符串'

    %   表示：任意字符 任意次数
    _   表示：任意字符 单次

    sql 的模式匹配没有默认转义字符，可以指定转义字符
    like '模式子串' escape '转义字符'

查询员工首字母是S的员工信息
    select *
    from emp
    where ename like 'S%'

查询名字是四个字母的员工信息
    select *
    from emp
    where ename like '____'

查询姓名带下划线的员工信息
insert into emp values(8000,'A_B','CLERK',7902,sysdate,900,null,20);
    select * 
    from emp
    where ename like '%\_%' escape '\'
```

## 2.6 排序

```sql
    select ...
    from ....
    where ...
    order by 列名1,列名2... desc|asc
    
--  asc  从小到大 升序  (默认)
--  desc 从大到小 降序
--  desc和asc 只对单列生效；对多列分别指定 会对指定的这些列分别生效

员工信息按先后入职日期排序
    select * 
    from emp 
    order by hiredate

员工信息按薪水从大到小排序 
    select *
    from emp
    order by sal desc

员工信息按部门号和薪水排列
    select *
    from emp
    order by deptno , sal

    排序的规则，先排第一列，第一列相同的情况下再按照第二列来排序
    以此类推

员工信息按部门和薪水排列，降序 
-- desc和asc 只对单列生效
    select *
    from emp
    order by deptno desc, sal desc

员工信息按奖金倒序
    select *
    from emp
    order by comm desc nulls last|first

    结论：
        null值会影响排序

员工信息按第2列排序
-- 按照第几列来排序是指结果集的第几列，不是表的第几列
    select ename , empno
    from emp
    order by 2
	

员工信息按别名排序
    select ename , empno "工号"
    from emp
    order by "工号"
```

## 2.7 字符函数：单行函数

```sql
	lower   将字符串转为小写
    upper   将字符串转为大写
    initcap 将首字母变成大写
select lower('hELLO'),upper('heLlo'),initcap('hEllO') 
from dual
        LOWER UPPER INITC
		----- ----- -----
        hello HELLO Hello
        
concat
	select concat('hello ','world') 
    from dual
-- concat 默认只接收两个参数
    select concat('hello ',concat('world','aaa')) 
    from dual;
-- oracle还提供另一种方法，使用 ||
    select 'hello'||'world'||123||456 
    from dual

substr
	select substr('helloworld',3),substr('helloworld',3,5) 
    from dual
substr(字符串,起始位置)    从起始位置开始一直取到字符串的结尾
substr(字符串,起始位置,n) 从起始位置开始取n个字符

instr  用来查找A字符串在B字符串中的位置
    select instr('helloworld','llo') 
    from dual

lpad,rpad   左右填充
-- 将字符串进行填充到10的长度，如果不够就填充#号
    select lpad('hello',10,'#') 
    from dual

trim  裁剪字符串两边空白的字符
    select trim('   Hello   ') 
    from dual;
-- 指定裁剪字符串两边特定的字符
-- 裁剪字符串两边大写的H
    select trim('H' from 'HHHHhelloHHHHH') 
    from dual;

replace
    select replace('hello','l','*') 
    from dual;
```

## 2.8 数值函数

```sql
    round   四舍五入
    trunc   截取数值
    ceil、floor  向上取整、向下取整
    mod     取模 ， %
	
	select 
		round(45.926,2),
		trunc(45.926,2),
		ceil(45.926),
		floor(45.926),
        mod(1000,600)
	from dual
```

## 2.9 转换函数

```sql
to_char ：数字转字符串 
		to_char(数值表达式,'格式字符串')
        格式字符串：
            L 本地货币符号
            9 表示一位数值
--  将薪水转化为本地货币字符型
	select empno,ename,sal,to_char(sal,'L9999.99') 
	from emp
        
to_number：字符串转数字 
    select to_number('￥800.00','L9999.99') 
    from dual;

to_char：日期转字符串 
    select empno,ename,to_char(hiredate,'dd,mm,yyyy') 
    from emp;

to_date：字符串转日期 
    select to_date('17,12,1980','dd,mm,yyyy') 
    from dual

说明：
	to_char用什么格式字符串，to_number或者to_date就可以使用该格式字符串转化回来
```
## 2.10 日期函数

```sql
sysdate
	-- 显示昨天、今天、明天
	select sysdate - 1 昨天,sysdate 今天 , sysdate +1 明天 
	from dual
	
-- 时间日期数据类型计算单位是1天

    -- 计算员工工龄，按照日、周、月、年显示
	select sysdate-hiredate 日,
           (sysdate-hiredate)/7 周,
           (sysdate-hiredate)/30 月,
           (sysdate-hiredate)/365 年 
	from emp


months_between 
-- 计算两个时间日期的数值相差多少个月
	select sysdate-hiredate 日,
           (sysdate-hiredate)/7 周,
           (sysdate-hiredate)/30 月,
           months_between(sysdate,hiredate) 月2,
           (sysdate-hiredate)/365 年 
    from emp

add_months
-- 计算明年今日
	select add_months(sysdate,12) 
	from dual

last_day
-- 计算月份的最后一天
	select last_day(sysdate) 
	from dual

next_day
-- 计算下一个星期几
	select next_day(sysdate,'星期五') 
	from dual
```
## 2.11 通用函数

```sql
nvl(exp,val)
	如果exp 为null ，就返回val

nvl2(exp,val1,val2)
	如果exp为null，就返回val2，否则返回val1

	-- 查询员工信息，有奖金就显示'有奖金'，没奖金就显示'没奖金'
    select ename,nvl2(comm,'有奖金','没奖金') 
    from emp
```

## 2.12 条件语句

```sql
    case when then else end
    decode
    总裁决定给大家涨工资，主管涨1000，销售涨500，其他涨200
        switch(job)
        {
            case 'MANAGER':  sal+1000; break;
            case 'SALESMAN' : sal + 500 ;break;
            default : sal+200 ; break;
        }

case 是sql标准
    select ename,job,sal "涨前工资",
        case job
            when 'MANAGER' then sal + 1000
            when 'SALESMAN' then sal + 500
            else sal+200
        end "涨后工资"
    from emp

    decode 不是sql标准，oracle自身拓展出来
        decode(expr,val1,val2,val3,val4 ....,default)
            判断表达式expr 的值，如果为val1,就返回val2
            如果为val3,就返回val4 依次类推，如果都不是，就返回最后一个default
        select ename,job,sal "涨前工资",
            decode(job,'MANAGER',sal+1000,'SALESMAN',sal+500,sal+200) "涨后工资"
        from emp
```
## 2.13 统计函数：多行计算函数

```sql
-- 多行函数相对于单行的函数来说，必须遍历整个表或者部分数据才可以计算出结果

sum
	-- 求员工工资总和
    select sum(sal) 
    from emp

count 只要某一行某一列有值，count就会+1
    -- 求员工数量,有奖金的员工数
    select count(empno),count(*),count(comm) 
    from emp
    
    select sum(1) 
    from emp;
    
说明：
	null不会参与统计函数的计算

	-- 求工作岗位数量
    select count(distinct job) 
    from emp

max/min
    求员工最高工资和最低工资

avg
    -- 求员工平均工资
    select avg(sal) 
    from emp
    
    -- 求员工平均奖金（三种方式）
    select sum(comm)/count(*),
           sum(comm)/count(comm),
           avg(comm)
	from emp
```

## 2.14 分组统计


```sql
select ..
from ...
where cond1
group by 列1,列2...       #根据某一列或者多列来分组
having cond2

	-- 查询各部门平均工资
    select * -- 此处是错误示范
    from emp
    group by deptno

-- 注意：如果使用了group by来进行分组，select后面的列有限制
-- 能填的只能是group by 中出现过的列， 或者是 统计函数
    
    select deptno,avg(sal)
    from emp
    group by deptno

小结：
	多行函数（统计函数）在没有分组的前提下，统计的是全表
	(有where就是通过where筛选)的数据，
	在有分组的前提下，统计的就是分组


	-- 查询平均薪水大于2000的部门
    select deptno,avg(sal)
    from emp
    where avg(sal)>2000 --第3行出现错误:ORA-00934: 此处不允许使用分组函数
    group by deptno
--注意：在where条件中不允许使用统计函数
-- 使用having
    select deptno,avg(sal)
    from emp
    group by deptno
    having avg(sal) > 2000

	-- 求10号部门员工的平均薪水
    select deptno , avg(sal)
    from emp
    where deptno = 10
    group by deptno
-- 换成having
    select deptno , avg(sal)
    from emp
    group by deptno
    having deptno = 10

having与where的区别
--结论：能够用where 就不要用having

-- sql查询先后顺序：
    select ...
    from ...
    where cond1
    group by ....
    having cond2
    order by ...
1 遍历表，查询数据，每一行数据都要进行严格筛选，筛选条件就是where cond1,得到结果集1
2 对结果集1求分组 ，计算统计函数的表达式的值，得到结果集2
3 对结果集2 进行筛选，筛选条件就是 having cond2  ，得到结果集3
4 排序
5 之后筛选出我们想要的列，返回最终结果集

where筛选是先于having筛选的，
先在where进行筛选，能够减少后边计算的数据量,从而提高查询语句性能
```

## 2.15 多表查询
```sql
--多表查询：要获取的数据不在同一个表中，要使用多表查询
	select ...
    from 表1,表2....
    where ...

	--查询员工信息：员工号，姓名，月薪和部门名称
    --员工、姓名、月薪 在 EMP表
    --部门名称 在 dept
    select empno,ename,sal,dname,e.deptno
    from emp e,dept d
    where e.deptno = d.deptno

--join on：另外一个连接的语法(SQL标准)，使用 join on
--将from 后面的逗号，换成join ，where 换成on
    select empno,ename,sal,dname,e.deptno
    from emp e join dept d
    on e.deptno = d.deptno 
    
--多表查询也称为表的连接，where筛选的条件就称为连接条件

--根据连接条件里边使用的是等号还是不等号，可以称为等值连接和不等值连接
	
	--查询员工信息：员工号，姓名，月薪和月薪级别（salgrade表）
    select empno,ename,sal,grade 
    from emp,salgrade
    where sal between losal and hisal

	--按部门统计员工人数，显示如下信息：部门号，部门名称，人数（注意统计40号部门）
    select d.deptno,d.dname,count(empno)
    from dept d , emp e
    where d.deptno = e.deptno(+) -- 左外连接
    group by d.deptno,d.dname
-- sql标准：
    select d.deptno,d.dname,count(empno)
    from dept d left join emp e-- 左外连接
    on d.deptno = e.deptno
    group by d.deptno,d.dname
    
--外连接：如果想保留没有通过连接条件而被筛选的数据，那么就使用外连接

--分方向，这是oracle的特有的玩法
    想保留哪一张表的额外的数据，就在连接条件等号的另一边使用(+)

--左外连接
    想保留左边表的数据，使用左外连接
    就在等号右边使用(+)

--右外连接
    想保留右边表的数据，使用右外连接
    就在等号左边使用(+)
```

## 2.16 自连接
```sql
-- 自连接：要查询的数据在同一张表，但是不在同一行，表自己跟自己做表连接
	
	--查询员工信息：将员工的主管名字也显示出来（KING的主管是他自己）
	select e.ename || '''s manager is '|| nvl(e2.ename,'his wife')
    from emp e ,emp e2
    where e.mgr = e2.empno (+)

-- sql中的字符串，使用两个单引号来转义输出单个单引号
```

## 2.17 子查询

```sql
-- 子查询：一个select语句里边可以嵌套其他select语句，就是子查询
	
	--查询比scott工资高的员工信息 
    1 先查询出scott的工资
        select sal 
        from emp 
        where ename = 'SCOTT'  -- 3000 
    2 查询工资大于3000的员工信息
        select * 
        from emp 
        where sal > 3000

    select * 
    from emp 
    where sal >(
        --查询出scott的工资
        select sal 
        from emp 
        where ename = 'SCOTT'
        )

--注意事项
	注意书写风格
	父查询和子查询可以是不同的表，子查询返回的结果父查询可以使用即可
    
    --查询部门名称是 'SALES' 的员工信息
    --1 先查询出salse部门编号(先根据部门名称查询出部门编号)
    --2 查询出是该部门编号的所有员工信息(然后根据部门编号查询出所有的员工信息)
    select *
    from emp
    where deptno =
    (
        --查询出sales的部门编号
        select deptno
        from dept
        where dname = 'SALES'
    )
 
--父查询的select、from、where、having都可以嵌套子查询
    select ...
    from ...
    where ...
    group by ...   --不能后置子查询
    having ...
    order by ...   --不能后置子查询

    -- select 后置子查询：
    -- 查询10号部门的员工号、员工姓名、部门编号、部门名称
    select empno,ename,deptno ,
            (
            --将10号部门的名称查询出来
			select dname 
            from dept
            where deptno = 10
            ) "部门名称"
	from emp
    where deptno = 10

    --from 后置子查询： 
    --查询员工的姓名、月薪和年薪（使用select * from _________)
        select *
        from (
            select ename,sal,sal*13 年薪
            from emp
        )

    --where后置子查询： 
    --查询与ward(雇员名字)相同岗位并且月薪比他高的员工信息
        1 查询ward的岗位
            select job 
            from emp 
            where ename = 'WARD'
        2 查询ward的工资
            select sal 
            from emp 
            where ename= 'WARD'
        3 拼凑，查询岗位相同，工资比其高的员工的信息
            select *
            from emp
            where job= 
            (
                --ward的岗位
                select job 
                from emp 
                where ename = 'WARD'
            )
            and sal > 
            (
                --ward的工资
                select sal 
                from emp 
                where ename= 'WARD'
            )
    
    --having后置子查询：
    --查询部门最低月薪高于30号部门的部门以及其最低月薪
        1 查询30号部门的最低月薪
            select min(sal)
            from emp
            where deptno = 30
            --950
        2 确定哪个部门的最低月薪比30号部门要高
            select deptno,min(sal)
            from emp
            group by deptno

        select deptno,min(sal)
        from emp
        group by deptno
        having min(sal) > 
        (                
            select min(sal)
            from emp
            where deptno = 30
        )
* 单行子查询只能使用单行操作符，多行子查询只能使用多行操作符 （这里都是指单列）
    单行操作符，就是对某个单一数据的比较操作
    =|>|>=|<|<=等
    
* 多行操作符，就是对一个集合的比较操作(IN、ANY、ALL)
 
    查询部门名称为SALES和ACCOUNTING的员工信息 (IN)
        in 跟单行操作符 = 对应
        1 先查询出 sales 和 accounting 的部门编号
            select deptno from dept where dname ='SALES' or dname = 'ACCOUNTING'
            --10,30
        2 再查询出是这两个部门编号的员工信息
            select *
            from emp
            where deptno in (10,30)
        select *
        from emp
        where deptno in (
            select deptno 
            from dept 
            where dname ='SALES' or dname = 'ACCOUNTING'
        )
    查询月薪比30号部门任意一个（某一个any）员工高的员工信息
        查询比30号部门最低月薪高的员工信息

        1 先查询出 30部门的最低月薪   --950
        2 查询比950 高的员工信息

        select *
        from emp
        where sal > any
        (
            --先将30号部门的所有员工的月薪都查询出来
            select sal
            from emp
            where deptno = 30
        )
    查询比30号部门所有员工工资都高的员工信息
        查询比30号部门最高月薪高的员工信息

        select *
        from emp
        where sal > all
        (
            --先将30号部门的所有员工的月薪都查询出来
            select sal
            from emp
            where deptno = 30
        )
* 注意子查询中返回的null值影响最终计算结果

    查询不是主管的员工信息

        1 先查询是主管的empno
            select mgr from emp
        2 取反
            select *
            from emp
            where empno not in( 
                select mgr from emp
            )
    假设 select mgr from emp  结果是 (7902,7698,null)

        where empno not in ( 7902,7698,null)
        换算成C的代码
            empno!=7902 && empno!=7698 && empno!=null
            昨天的结论：null做任何逻辑运算，结果都为假

    如果题设是查询是主管的信息
        where empno in ( 7902,7698,null)
            empno==7902 || empno==7698 || empno==null

* SQL解析：一般先执行子查询（内查询），再执行父查询（外查询）；关联子查询除外
        一般子查询只执行一次，先于父查询来执行,关联子查询除外
```

## 2.18 集合运算

    交集：             intersect
        多个集合都有的那部分
    并集：             union
        将多个集合合在一起 (去重)
    全并集：            union all
        将多个集合合在一起（不去重）
    差集：分方向         minus
        求一个集合对于另一个集合没有的那部分


    部门号是10的员工和部门号是20的员工信息做并集（以及全并集）
        select *
        from emp
        where deptno = 10
    
        union
    
        select *
        from emp
        where deptno = 20
    
    用10号部门的员工信息和 10,20号部门的员工信息做交集
        select *
        from emp
        where deptno in (10,20)
    
        intersect
    
        select *
        from emp
        where deptno = 10
    
    用10,30的员工减去10,20的员工信息
        select *
        from emp
        where deptno in (10,30)
    
        minus
    
        select *
        from emp
        where deptno in (10,20)


​    
    查询三个部门的工资信息并分组统计，格式如下：
        DEPTNO JOB                  SUM(SAL)
    ---------- ------------------ ----------
            10 CLERK                    1300
               MANAGER                  2450
               PRESIDENT                5000
                                        8750
    
            20 ANALYST                  6000
               CLERK                    1900
               MANAGER                  2975
                                       10875
    
            30 CLERK                     950
               MANAGER                  2850
               SALESMAN                 5600
                                        9400
    
                                       29025
    提示：
        SQL plus中使用一下命令来去掉分组重复的deptno
            break on deptno skip 2;
        使用以下命令来恢复
            break on null;


    以上的结果是使用3个集合拼凑在一起
        1 每个部门，每个岗位的工资总和
            select deptno,job,sum(sal)
            from emp
            group by deptno , job
                DEPTNO JOB         SUM(SAL)
            ---------- --------- ----------
                    20 CLERK           1900
                    30 SALESMAN        5600
                    20 MANAGER         2975
                    30 CLERK            950
                    10 PRESIDENT       5000
                    30 MANAGER         2850
                    10 CLERK           1300
                    10 MANAGER         2450
                    20 ANALYST         6000
        2 每个部门的工资总和
            select deptno,sum(sal)
            from emp
            group by deptno
    
                DEPTNO   SUM(SAL)
            ---------- ----------
                    30       9400
                    20      10875
                    10       8750
        3 整个公司的工资总和
            select sum(sal)
            from emp
                      SUM(SAL)
                    ----------
                         29025


        将以上3个集合拼在一起
            select deptno,job,sum(sal)
            from emp
            group by deptno , job
    
            union
    
            select deptno,null,sum(sal)
            from emp
            group by deptno
    
            union
    
            select null,null,sum(sal)
            from emp


集合运算注意事项：
    * 参与运算的各个集合必须列数相同，且类型一致
        * 采用第一个集合的表头作为最终使用的表头，（别名也只能在第一个集合上起）
        * 可以使用括号修改各个sql执行的优先级


## 新增数据：

    insert into 表名 values(val1,val2,val3....)
        根据表的设计，将val1,val2对应上每一列的定义，进行插入
    insert into 表名(列名1,列名2,....) values(val1,val2 ....)
        根据前面列的顺序来调整values里边这些字段值的顺序
    
    往部门表里边插入以下几行信息
        DEPTNO DNAME                        LOC
    ---------- ---------------------------- --------------------------
            50 SUPPORT                      WASHINGTON
            60 TEST
            70 PURCHASING


        insert into dept values(50,'SUPPORT','WASHINGTON')
        insert into dept(deptno,loc,dname) values(60,null,'TEST')
        insert into dept(deptno,dname) values(70,'PURCHASING')

## 修改数据
​    update 表名 set 列名1=值1 , 列名2 = 值2...  [where cond]

    将60号部门的LOC改成MIAMI
        update dept set loc='MIAMI' where deptno=60
    
    将50号部门的部门名字改成 SUPPORT1 ，LOC改为NULL
        update dept set dname='SUPPORT1' , loc = null where deptno = 50

## 删除数据

    delete from 表名 where cond
        删除数据都是以行为单位
    
    删除部门号为50的部门信息
        delete from dept where deptno = 50
    删除部门号大于40的部门信息
        delete from dept where deptno > 40

## 事务

    银行转账
    
        A   100
        B    0
        C   100
    
        update  将 A - 100
            机房断电
            B销户了
        update  将 B + 100




    隔离级别
    
        某表某一行某一列有一个值  0
    
    1 读未提交
        事务A 开启
                                事务B 开启
                                读取该值 0
        修改该值为100                                
                                读取该值 100
        提交事务



    2 读已提交  （Oracle默认）
        事务A 开启
                                事务B 开启
                                读取该值 0
        修改该值为100                                
                                读取该值 0
        提交事务commit
                                读取该值 100
                                结束事务
    
    3 可重复读  （MySQL默认）
        事务A 开启
                                事务B 开启
                                读取该值 0
        修改该值为100                                
                                读取该值 0
        提交事务commit
                                读取该值 0
                                结束事务
                                                事务C 开启
                                                读取该值 100
                                                结束事务
    4 串行化   
        相当于单线程 ，服务器上同一时刻只有一个事务在跑
    
        事务A 开启
        修改该值为100    
        提交事务commit            
                                事务B 开启
                                读取到 100
                                结束事务



## 事务的控制
​    在事务的过程中可以使用 
​    savepoint  保存点名字 
​        创建一些保存点
​        下次如果发现之前某一步做错了，不至于直接 rollback回到原始事务
​        开始的地方
​        可以
​    rollback to savepoint 保存点名字

    一但当前事务提交或者回滚，在当前事务建立的savepoint将失效

## 习题
【第一题】：      找到员工表中工资最高的前三名， 要求按如下格式输出

    补充知识 rownum 行号   
        select rownum , emp.* from emp 
        看到行号，行号是筛选数据的过程中自动生成的，并不真正存在于表中


    select rownum , ename, sal 
    from emp
    order by sal desc
    
    行号是乱的，工资的降序是对的
    结论：行号在排序前已经生成好了
    
    思路：
        先排序，再生成行号 
        再筛选 行号 < 3
    
        子查询先排序，父查询生成行号


    延伸的问题： 分页问题，按照工资降序排序，取5-8 名 
    
        也是依赖行号
    
        rownum不能直接用 > 来比较  ，除了 >=1 


【第二题提示】：        找到emp表中薪水大于本部门平均薪水的员工
    empno ename sal avgsal

        多表查询   ,自行构造另一张表 
        from 后置子查询
【第三题提示】：        统计每年入职的员工个数


    1980 1
    1981 2 
    .....
    
    可以使用01 标记法  ，依赖 条件语句
    
                1980   1981   1982  ....
        1980      1      0      0
        1981      0      1
        1981      0      1
        1981
        1981
        1981
        1981
        1987
        1981
        1981
        1987
        1981
        1981
        1982







​    