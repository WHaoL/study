# 1.为什么要学习数据库

```sql
-- 市面上99%的软件都会用到数据库

-- 查询、增、删、改、创表删表等操作
```
# 2.Oracle数据库

## 2.1 登录

```sql
-- 数据库启动关闭    
    -- 以oracle用户登录linux

    -- sqlplus / as sysdba
        -- 以数据库管理员的方式登录oracle数据库 ，默认用户名是sys
    -- sql>  startup 
        -- 启动数据库实例  （在sqlplus中执行）
        -- 实例：oracle的一组服务

    -- sql>  shutdown   
        -- 关闭数据库实例
    -- exit  退出sqlplus
-- 数据库监听服务启动和关闭

    -- lsnrctl start
        -- 启动数据库的监听服务
        -- 如果不启动监听服务，oracle远程没有办法连接上的

    -- lsnrctl stop
        -- 关闭数据库监听服务

    -- lsnrctl status
        -- 查看监听服务的状态
-- 修改scott用户密码
    -- 必须要oracle的管理员权限去修改
    -- sqlplus / as sysdba 
    -- sql> alter user scott identified by "123456" ;

-- 登录scott用户

    -- sqlplus 用户名/密码
        -- 本地登录
        -- sqlplus scott/11

    -- sqlplus 用户名/密码@//服务器ip/实例名(orcl)
        -- 远端登录

    -- sqlplus scott/11@//192.168.177.233/orcl

-- 查看scott用户方案所拥有的表
    -- 使用scott用户登陆之后
    -- select * from tab;
```

## 2.2 简单查询：

```sql
select * 
from tableName;

select 列名1 as "别名1",列名2,表达式.... 
from 表名
```



```sql
-- 查询emp表的所有数据  
	select * 
	from emp;

-- 设置行宽 
	set linesize 140;

-- 设置页高 
	set pagesize 50;

-- 查询员工号，姓名，月薪，奖金，年薪，年收入 并修改列名为中文
    select 
    	empno as "工 号",
    	ename as 姓名,
    	sal 月薪,
    	comm 奖金 ,
    	sal*13 年薪, 
    	sal*13 + nvl(comm,0)  年收入
    from emp;

-- 小结：
    -- 1 sql查询可以按照列名来查询
    -- 2 可以使用表-- 达式作为列名，数据库会自动计算出每一列每一行表达式的值
    -- 3 可以对列起别名

-- nvl 函数：nvl(f1,f2)
	-- 如果参数1(表达式)为null，则返回参数2

-- null 数据类型 
	-- 做任何的数值运算结果都为null

-- 查看员工表所有部门编号并去除重复
    select distinct deptno 
    from emp;
-- 说明：
	-- distinct 的作用：就是去除重复的行

-- 计算表达式3+2
    select 3+2 
    from dual
-- 说明：
	-- dual是一张虚表，我们可以从这张表里边去计算表达式
```

## 2.3 单条件查询：

```sql
-- select ...
from ...
where cond

-- 查询10号部门的员工信息
    select * 
    from emp 
    where deptno = 10;

-- 查询员工KING的信息
    select * 
    from emp 
    where ename = 'KING';

-- 注意：数据中的字符串是大小写敏感的

-- 单引号和双引号的说明：
    -- 数据中的字符串，使用单引号
    -- 单引号用于数据的字符串
    -- 双引号用于数据库对象名 ，表名 列名 ...

-- 查询薪水不等于1250的员工信息
-- 大于      小于      不等于       等于
> >=     <  <=      !=  <>      =
    select * 
    from emp 
    where sal <> 1250;

-- 查询入职日期为1981年11月17日的员工信息
    -- 日期的比较可以直接使用字符串来比较，数据库会自动做一个隐式的转换
        select * 
        from emp 
        where hiredate = '1981-11-17';
    -- ORA-01861: 文字与格式字符串不匹配
    -- 当用字符串跟日期进行比较的时候，注意日期格式
    
    -- 查询当前会话的环境变量
    select * 
    from v$nls_parameters;    
      
    select * 
    from emp 
    where hiredate = '17-11月-81'
    
    -- 修改当前会话的时间日期格式字符串
    alter session 
    set NLS_DATE_FORMAT='yyyy-mm-dd' 
```

## ed 命令

```sql
-- sqlplus 中 使用 ed 命令，打开一个编辑器，用来编辑上一条执行过的sql语句
-- 修改这条语句（最后不要使用分号），换行之后添加一个单独的 / 表示结束  ，保存退出，
-- 然后敲入/回车执行上一条指令
```



## 2.4 多条件查询：

```sql
--       -- 与       或       非
    C   &&       ||       !
    sql and      or       not

-- 查询10号部门中月薪为1300的员工
    select * 
    from emp 
    where deptno=10 and sal =1300

-- 查询部门号是10或者20的员工信息
    select * 
    from emp 
    where deptno = 10 or deptno = 20

    select * 
    from emp
    where deptno in (10,20)

-- 查询部门不是10和20的员工信息
    select * 
    from emp
    where deptno not in (10,20)

-- 查询工资介于1000到2000之间的员工
    select *
    from emp
    where sal >=1000 and sal <=2000

    select *
    from emp
    where sal between 1000 and 2000
    -- between and 是一个闭区间

-- 查询1981年2月（含2月）到82年2月（不含2月）入职的员工信息
    1981-2-1   1982-1-31

    select * 
    from emp
    where hiredate between '1981-02-01' and '1982-01-31'

-- 查询没有奖金的员工信息
    select * 
    from emp
    where comm = null

    -- 结论：
    --     null做任何逻辑运算，结果都为假

	-- 用下面这个
    select *
    from emp
    where comm is null

-- 查询有奖金的员工信息
    select *
    from emp
    where comm is not null
```

## 2.5 模糊查询

```sql
-- 每次掉线之后重新连接之后都要设置行宽页高的问题
-- 配置 C:\app\itcast\product\11.2.0\client_1\sqlplus\admin\glogin.sql
--         每次登录sqlplus之后都会马上执行的一些指令
```




```sql
select ..-- .
from ..
where 列名 like '模式字符串'

--     %   表示：任意字符 任意次数
--     _   表示：任意字符 单次

--     sql 的模式匹配没有默认转义字符，可以指定转义字符
--     like '模式子串' escape '转义字符'

-- 查询员工首字母是S的员工信息
    select *
    from emp
    where ename like 'S%'

-- 查询名字是四个字母的员工信息
    select *
    from emp
    where ename like '____'

-- 查询姓名带下划线的员工信息
insert into emp values(8000,'A_B','CLERK',7902,sysdate,900,null,20);
    select * 
    from emp
    where ename like '%\_%' escape '\'
```

## 2.6 排序

```sql
--     select ...
    from ....
    where ...
    order by 列名1,列名2... desc|asc
    
--  asc  从小到大 升序  (默认)
--  desc 从大到小 降序
--  desc和asc 只对单列生效；对多列分别指定 会对指定的这些列分别生效

-- 员工信息按先后入职日期排序
    select * 
    from emp 
    order by hiredate

-- 员工信息按薪水从大到小排序 
    select *
    from emp
    order by sal desc

-- 员工信息按部门号和薪水排列
    select *
    from emp
    order by deptno , sal

--     排序的规则，先排第一列，第一列相同的情况下再按照第二列来排序
--     以此类推

-- 员工信息按部门和薪水排列，降序 
-- desc和asc 只对单列生效
    select *
    from emp
    order by deptno desc, sal desc

-- 员工信息按奖金倒序
    select *
    from emp
    order by comm desc nulls last|first

--     结论：
--         null值会影响排序

-- 员工信息按第2列排序
-- 按照第几列来排序是指结果集的第几列，不是表的第几列
    select ename , empno
    from emp
    order by 2
	

-- 员工信息按别名排序
    select ename , empno "工号"
    from emp
    order by "工号"
```

## 2.7 字符函数：单行函数

```sql
-- 	lower   将字符串转为小写
--  upper   将字符串转为大写
--  initcap 将首字母变成大写
select lower('hELLO'),upper('heLlo'),initcap('hEllO') 
from dual
        LOWER UPPER INITC
		----- ----- -----
        hello HELLO Hello
        
concat
	select concat('hello ','world') 
    from dual
-- concat 默认只接收两个参数
    select concat('hello ',concat('world','aaa')) 
    from dual;
-- oracle还提供另一种方法，使用 ||
    select 'hello'||'world'||123||456 
    from dual

substr
	select substr('helloworld',3),substr('helloworld',3,5) 
    from dual
substr(字符串,起始位置)    从起始位置开始一直取到字符串的结尾
substr(字符串,起始位置,n) 从起始位置开始取n个字符

instr  用来查找A字符串在B字符串中的位置
    select instr('helloworld','llo') 
    from dual

lpad,rpad   左右填充
-- 将字符串进行填充到10的长度，如果不够就填充#号
    select lpad('hello',10,'#') 
    from dual

-- trim  裁剪字符串两边空白的字符
    select trim('   Hello   ') 
    from dual;
-- 指定裁剪字符串两边特定的字符
-- 裁剪字符串两边大写的H
    select trim('H' from 'HHHHhelloHHHHH') 
    from dual;

replace
    select replace('hello','l','*') 
    from dual;
```

## 2.8 数值函数

```sql
    round   四舍五入
    trunc   截取数值
    ceil、floor  向上取整、向下取整
    mod     取模 ， %
	
	select 
		round(45.926,2),
		trunc(45.926,2),
		ceil(45.926),
		floor(45.926),
        mod(1000,600)
	from dual
```

## 2.9 转换函数

```sql
-- to_char ：数字转字符串 
-- 		to_char(数值表达式,'格式字符串')
--         格式字符串：
--             L 本地货币符号
--             9 表示一位数值
--  将薪水转化为本地货币字符型
	select empno,ename,sal,to_char(sal,'L9999.99') 
	from emp
        
to_number：字符串转数字 
    select to_number('￥800.00','L9999.99') 
    from dual;

to_char：日期转字符串 
    select empno,ename,to_char(hiredate,'dd,mm,yyyy') 
    from emp;

to_date：字符串转日期 
    select to_date('17,12,1980','dd,mm,yyyy') 
    from dual

说明：
	to_char用什么格式字符串，to_number或者to_date就可以使用该格式字符串转化回来
```
## 2.10 日期函数

```sql
sysdate
	-- 显示昨天、今天、明天
	select sysdate - 1 昨天,sysdate 今天 , sysdate +1 明天 
	from dual
	
-- 时间日期数据类型计算单位是1天

    -- 计算员工工龄，按照日、周、月、年显示
	select sysdate-hiredate 日,
           (sysdate-hiredate)/7 周,
           (sysdate-hiredate)/30 月,
           (sysdate-hiredate)/365 年 
	from emp


months_between 
-- 计算两个时间日期的数值相差多少个月
	select sysdate-hiredate 日,
           (sysdate-hiredate)/7 周,
           (sysdate-hiredate)/30 月,
           months_between(sysdate,hiredate) 月2,
           (sysdate-hiredate)/365 年 
    from emp

add_months
-- 计算明年今日
	select add_months(sysdate,12) 
	from dual

last_day
-- 计算月份的最后一天
	select last_day(sysdate) 
	from dual

next_day
-- 计算下一个星期几
	select next_day(sysdate,'星期五') 
	from dual
```
## 2.11 通用函数

```sql
-- nvl(exp,val)
-- 	如果exp 为null ，就返回val
-- 
-- nvl2(exp,val1,val2)
-- 	如果exp为null，就返回val2，否则返回val1

	-- 查询员工信息，有奖金就显示'有奖金'，没奖金就显示'没奖金'
    select ename,nvl2(comm,'有奖金','没奖金') 
    from emp
```

## 2.12 条件语句 case、decode

```sql
--     case 
--     		when 
--     		then 
--     		else 
--     end
--     总裁决定给大家涨工资，主管涨1000，销售涨500，其他涨200
        switch(job)
        {
            case 'MANAGER':  sal+1000; break;
            case 'SALESMAN' : sal + 500 ;break;
            default : sal+200 ; break;
        }
-- case 是sql标准
    select ename,job,sal "涨前工资",
        case job
            when 'MANAGER' then sal + 1000
            when 'SALESMAN' then sal + 500
            else sal+200
        end "涨后工资"
    from emp

-- decode 不是sql标准，oracle自身拓展出来
--         decode(expr,val1,val2,val3,val4 ....,default)
--             判断表达式expr 的值，如果为val1,就返回val2
--             如果为val3,就返回val4 依次类推，如果都不是，就返回最后一个default
   select ename,job,sal "涨前工资",
          decode(job,
                 'MANAGER',sal+1000,
                 'SALESMAN',sal+500,
                 sal+200)
           "涨后工资"
   from emp
```
## 2.13 统计函数：多行计算函数

```sql
-- 多行函数相对于单行的函数来说，必须遍历整个表或者部分数据才可以计算出结果

-- sum
	-- 求员工工资总和
    select sum(sal) 
    from emp

-- count 只要某一行某一列有值，count就会+1
    -- 求员工数量,有奖金的员工数
    select 
    	count(empno),
    	count(*),
    	count(comm) 
    from emp
    
    select sum(1) 
    from emp;
    
-- 说明：
-- 	null不会参与统计函数的计算

	-- 求工作岗位数量
    select count(distinct job) 
    from emp

-- max/min
--     求员工最高工资和最低工资

-- avg
    -- 求员工平均工资
    select avg(sal) 
    from emp
    
    -- 求员工平均奖金（三种方式）
    select 
    	   sum(comm)/count(*),
           sum(comm)/count(comm),
           avg(comm)
	from emp
```

## 2.14 分组统计


```sql
-- -- select ..
-- -- from ...
-- -- where cond1
-- -- group by 列1,列2...       --根据某一列或者多列来分组
-- -- having cond2

	-- 查询各部门平均工资
    select * -- 此处是错误示范
    from emp
    group by deptno

-- 注意：如果使用了group by来进行分组，select后面的列有限制
-- 能填的只能是group by 中出现过的列， 或者是 统计函数
    
    select deptno,avg(sal)
    from emp
    group by deptno

-- 小结：
-- 	   多行函数（统计函数）在没有分组的前提下，统计的是全表
-- 	   (有where就是通过where筛选)的数据，
-- 	   在有分组的前提下，统计的就是分组


	-- 查询平均薪水大于2000的部门
    select deptno,avg(sal)
    from emp
    where avg(sal)>2000 --第3行出现错误:ORA-00934: 此处不允许使用分组函数
    group by deptno
--注意：在where条件中不允许使用统计函数
-- 使用having
    select deptno,avg(sal)
    from emp
    group by deptno
    having avg(sal) > 2000

	-- 求10号部门员工的平均薪水
    select deptno , avg(sal)
    from emp
    where deptno = 10
    group by deptno
-- 换成having
    select deptno , avg(sal)
    from emp
    group by deptno
    having deptno = 10

having与where的区别
--结论：能够用where 就不要用having

-- sql查询先后顺序：
    select ...
    from ...
    where cond1
    group by ....
    having cond2
    order by ...
-- 1 遍历表,查询数据,每一行数据都要进行严格筛选,筛选条件就是where cond1,得到结果集1
-- 2 对结果集1求分组 ，计算统计函数的表达式的值，得到结果集2
-- 3 对结果集2 进行筛选，筛选条件就是 having cond2  ，得到结果集3
-- 4 排序
-- 5 之后筛选出我们想要的列，返回最终结果集

-- where筛选是先于having筛选的，
-- 先在where进行筛选，能够减少后边计算的数据量,从而提高查询语句性能
```

## 2.15 多表查询

### 1. 多表查询

```sql
--多表查询：要获取的数据不在同一个表中，要使用多表查询
--	select ...
--  from 表1,表2....
--  where ...

	--查询员工信息：员工号，姓名，月薪和部门名称
    --员工、姓名、月薪 在 EMP表
    --部门名称 在 dept
    select empno,ename,sal,dname,e.deptno
    from emp e,dept d
    where e.deptno = d.deptno

--join on：另外一个连接的语法(SQL标准)，使用 join on
--将from 后面的逗号，换成join ，where 换成on
    select empno,ename,sal,dname,e.deptno
    from emp e join dept d
    on e.deptno = d.deptno 
```

### 2. 表的连接：等值连接和不等值连接

```sql
--多表查询也称为表的连接，where筛选的条件就称为连接条件

--根据连接条件里边使用的是等号还是不等号，可以称为等值连接和不等值连接
	
	--查询员工信息：员工号，姓名，月薪和月薪级别（salgrade表）
    select empno,ename,sal,grade 
    from emp,salgrade
    where sal between losal and hisal
```

### 3. 表的连接：外连接

```sql
	--按部门统计员工人数，显示如下信息：部门号，部门名称，人数（注意统计40号部门）
    select d.deptno,d.dname,count(empno)
    from dept d , emp e
    where d.deptno = e.deptno(+) -- 左外连接
    group by d.deptno,d.dname
-- sql标准：
    select d.deptno,d.dname,count(empno)
    from dept d left join emp e-- 左外连接
    on d.deptno = e.deptno
    group by d.deptno,d.dname
    
--外连接：如果想保留没有通过连接条件而被筛选掉的数据，那么就使用外连接

--分方向，这是oracle的特有的玩法
--     想保留哪一张表的额外的数据，就在连接条件等号的另一边使用(+)

--左外连接
--     想保留左边表的数据，使用左外连接
--     就在等号右边使用(+)

--右外连接
--     想保留右边表的数据，使用右外连接
--     就在等号左边使用(+)
```

## 2.16 自连接
```sql
-- 自连接：要查询的数据在同一张表，但是不在同一行，表自己跟自己做表连接
	
	--查询员工信息：将员工的主管名字也显示出来（KING的主管是他自己）
	select e.ename || '''s manager is '|| nvl(e2.ename,'his wife')
    from emp e ,emp e2
    where e.mgr = e2.empno (+)

-- sql中的字符串，使用两个单引号来转义输出单个单引号
```

## 2.17 子查询

```sql
-- 子查询：一个select语句里边可以嵌套其他select语句，就是子查询
-- 	
-- 	查询比scott工资高的员工信息 
--     1 先查询出scott的工资
        select sal 
        from emp 
        where ename = 'SCOTT'  -- 3000 
--     2 查询工资大于3000的员工信息
        select * 
        from emp 
        where sal > 3000

    select * 
    from emp 
    where sal >(
        --查询出scott的工资
        select sal 
        from emp 
        where ename = 'SCOTT'
        )

--注意事项
-- 	注意书写风格
-- 	父查询和子查询可以是不同的表，子查询返回的结果父查询可以使用即可

--  查询部门名称是 'SALES' 的员工信息
--  1 先查询出salse部门编号(先根据部门名称查询出部门编号)
--  2 查询出是该部门编号的所有员工信息(然后根据部门编号查询出所有的员工信息)
    select *
    from emp
    where deptno =
    (
        --查询出sales的部门编号
        select deptno
        from dept
        where dname = 'SALES'
    )
```

```sql
--父查询的select、from、where、having都可以嵌套子查询
    select ...
    from ...
    where ...
    group by ...   --不能后置子查询
    having ...
    order by ...   --不能后置子查询

--  select 后置子查询：
--  查询10号部门的员工号、员工姓名、部门编号、部门名称
--  select empno,ename,deptno ,
            (
            --将10号部门的名称查询出来
			select dname 
            from dept
            where deptno = 10
            ) "部门名称"
	from emp
    where deptno = 10

--  from 后置子查询： 
--  查询员工的姓名、月薪和年薪（使用select * from _________)
        select *
        from (
            select ename,sal,sal*13 年薪
            from emp
        )

--  where后置子查询： 
--  查询与ward(雇员名字)相同岗位并且月薪比他高的员工信息
--      1 查询ward的岗位
            select job 
            from emp 
            where ename = 'WARD'
--      2 查询ward的工资
            select sal 
            from emp 
            where ename= 'WARD'
--      3 拼凑，查询岗位相同，工资比其高的员工的信息
            select *
            from emp
            where job= 
            (
                --ward的岗位
                select job 
                from emp 
                where ename = 'WARD'
            )
            and sal > 
            (
                --ward的工资
                select sal 
                from emp 
                where ename= 'WARD'
            )
    
-- having后置子查询：
-- 查询部门最低月薪高于30号部门的部门以及其最低月薪
--     1 查询30号部门的最低月薪
            select min(sal)
            from emp
            where deptno = 30
            --950
--     2 确定哪个部门的最低月薪比30号部门要高
            select deptno,min(sal)
            from emp
            group by deptno
-- 		3 组合使用
            select deptno,min(sal)
            from emp
            group by deptno
            having min(sal) > 
            (                
                select min(sal)
                from emp
                where deptno = 30
            )
```

```sql
-- 单行子查询只能使用单行操作符，
-- 单行操作符，就是对某个单一数据的比较操作
--    =  >  >=  <  <= 等
```

```sql
-- 多行子查询只能使用多行操作符 （这里都是指单列）    
-- 多行操作符，就是对一个集合的比较操作
-- IN  ANY  ALL
 
    --查询部门名称为SALES和ACCOUNTING的员工信息 (IN)
    --in 跟单行操作符 = 对应
    --1 先查询出 sales 和 accounting 的部门编号
        select deptno 
        from dept 
        where dname ='SALES' or dname = 'ACCOUNTING'
        --10,30
    --2 再查询出是这两个部门编号的员工信息
        select *
        from emp
        where deptno in (10,30)
    --3 组合使用
        select *
        from emp
        where deptno in 
        (
            select deptno 
             from dept 
             where dname ='SALES' or dname = 'ACCOUNTING'
         )
            
--  查询月薪比30号部门任意一个（某一个any）员工高的员工信息
--  any
--  ANY(表示和集合中的任意一个值比较)： 
--      查询比30号部门最低月薪高的员工信息

--      1 先查询出 30部门的最低月薪   --950
--      2 查询比950 高的员工信息

        select *
        from emp
        where sal > any
        (
            --先将30号部门的所有员工的月薪都查询出来
            select sal
            from emp
            where deptno = 30
        )
--  查询比30号部门所有员工工资都高的员工信息
--  all
--      查询比30号部门最高月薪高的员工信息

        select *
        from emp
        where sal > all
        (
            --先将30号部门的所有员工的月薪都查询出来
            select sal
            from emp
            where deptno = 30
        )
-- 注意子查询中返回的null值影响最终计算结果
```





```sql
-- 查询不是主管的员工信息
-- 1 先查询是主管的empno
        select mgr 
        from emp
-- 2 取反
        select *
        from emp
        where empno not in
        	( 
            	select mgr 
                from emp
        	)
-- 假设 
-- 	select mgr 
-- 	from emp  
-- 结果是 (7902,7698,null)

    where empno 
    not in ( 7902,7698,null)
-- 换算成C的代码
--     empno!=7902 && empno!=7698 && empno!=null
-- 注意：null做任何逻辑运算，结果都为假

-- 如果题设是查询是主管的信息
        where empno in ( 7902,7698,null)
            empno==7902 || empno==7698 || empno==null

-- SQL解析：
--		一般先执行子查询（内查询），
--		再执行父查询（外查询）；
--		关联子查询除外
--      一般子查询只执行一次，先于父查询来执行,关联子查询除外
```



## 2.18 集合运算

    交集：             intersect
        多个集合都有的那部分
        
    并集：             union
        将多个集合合在一起 (去重)
        
    全并集：            union all
        将多个集合合在一起（不去重）
        
    差集：分方向         minus
        求一个集合对于另一个集合没有的那部分


```sql
-- 部门号是10的员工和部门号是20的员工信息做并集（以及全并集）
    select *
    from emp
    where deptno = 10

    union

    select *
    from emp
    where deptno = 20

-- 用10号部门的员工信息和 10,20号部门的员工信息做交集
    select *
    from emp
    where deptno in (10,20)

    intersect

    select *
    from emp
    where deptno = 10

-- 用10,30的员工减去10,20的员工信息
    select *
    from emp
    where deptno in (10,30)

    minus

    select *
    from emp
    where deptno in (10,20)
--  查询三个部门的工资信息并分组统计，格式如下：
        DEPTNO JOB                  SUM(SAL)
    ---------- ------------------ ----------
            10 CLERK                    1300
               MANAGER                  2450
               PRESIDENT                5000
                                        8750

            20 ANALYST                  6000
               CLERK                    1900
               MANAGER                  2975
                                       10875

            30 CLERK                     950
               MANAGER                  2850
               SALESMAN                 5600
                                        9400

                                       29025
--  提示：
--      SQL plus中使用以下命令来去掉分组重复的deptno
            break on deptno skip 2;
--      使用以下命令来恢复
            break on null;

--以上的结果是使用3个集合拼凑在一起

--    1 每个部门，每个岗位的工资总和
        select deptno,job,sum(sal)
        from emp
        group by deptno , job
        
            DEPTNO JOB         SUM(SAL)
        ---------- --------- ----------
                20 CLERK           1900
                30 SALESMAN        5600
                20 MANAGER         2975
                30 CLERK            950
                10 PRESIDENT       5000
                30 MANAGER         2850
                10 CLERK           1300
                10 MANAGER         2450
                20 ANALYST         6000
--    2 每个部门的工资总和
        select deptno,sum(sal)
        from emp
        group by deptno

            DEPTNO   SUM(SAL)
        ---------- ----------
                30       9400
                20      10875
                10       8750
--    3 整个公司的工资总和
        select sum(sal)
        from emp
                  SUM(SAL)
                ----------
                     29025
--  将以上3个集合拼在一起
        select deptno,job,sum(sal)
        from emp
        group by deptno , job

        union

        select deptno,null,sum(sal)
        from emp
        group by deptno

        union

        select null,null,sum(sal)
        from emp


```

- 集合运算注意事项：
     - 参与运算的各个集合必须列数相同，且类型一致
  - 采用第一个集合的表头作为最终使用的表头，（别名也只能在第一个集合上起）
  - 可以使用括号修改各个sql执行的优先级


## 2.19 新增数据：

```sql
-- insert into 表名 values(val1,val2,val3....)
--     根据表的设计，将val1,val2对应上每一列的定义，进行插入
--
-- insert into 表名(列名1,列名2,....) values(val1,val2 ....)
--     根据前面列的顺序来调整values里边这些字段值的顺序
--
-- 往部门表里边插入以下几行信息
    DEPTNO DNAME                        LOC
---------- ---------------------------- --------------------------
        50 SUPPORT                      WASHINGTON
        60 TEST
        70 PURCHASING
  
    insert into dept values(50,'SUPPORT','WASHINGTON')
    insert into dept(deptno,loc,dname) values(60,null,'TEST')
    insert into dept(deptno,dname) values(70,'PURCHASING')
```

## 2.20 修改数据


```sql
-- update 表名 
-- set 列名1=值1 , 列名2 = 值2...  
-- [where cond]
-- 
-- 将60号部门的LOC改成MIAMI
    update dept 
    set loc='MIAMI' 
    where deptno=60

-- 将50号部门的部门名字改成 SUPPORT1 ，LOC改为NULL
    update dept 
    set dname='SUPPORT1' , loc = null 
    where deptno = 50
```

## 2.21 删除数据

```SQL
-- delete 
-- from 表名 
-- where cond
-- 删除数据都是以行为单位

-- 删除部门号为50的部门信息
    delete 
    from dept 
    where deptno = 50
    
-- 删除部门号大于40的部门信息
    delete 
    from dept 
    where deptno > 40
```

## 2.22 事务

    银行转账
        A   100  --如果A向B转账100
        B    0   --此时端断点了或者B销户了
            update  将 A - 100 
                机房断电 / B销户了
            update  将 B + 100
    
        A   100  --如果A向B转账100(事务1)
        B    0   --此时端断点了或者B销户了
        C   100  --同时C也向B转账(事务2)
        -- 多个事务并行执行时，要和串行执行时结果一致

```sql
-- 事务由以下部分组成
-- 一个或多个 DML 语句 
-- 一个 DDL(Data Definition Language – 数据定义语言) 语句 
-- 一个 DCL(Data Control Language – 数据控制语言) 语句 
```



```sql
-- DML语句：增删查改  -- 数据操作语言
-- 增 insert
-- 删 delete
-- 改 update
-- 查 select
```

```sql
-- DDL语句 -- 数据定义语言 -- 一个DDL语句就是一个事务
-- create table(创建表) 
-- alter table(修改表) 
-- truncate table(清空表) 
-- drop table(删除表) 
-- create view(视图) 
-- create index(索引) 
-- create sequence(序列) 
-- create synonym(同义词) 
```

```sql
-- DCL语句：对事务进行操作  --数据控制语言（Data Control Language） 
-- commit(提交) 
-- rollback(回滚) 

```

## 2.23 隔离级别


    隔离级别
        某表某一行某一列有一个值  0
    
    1 读未提交
        事务A 开启
                                事务B 开启
                                读取该值 0
        修改该值为100                                
                                读取该值 100
        提交事务
    
    2 读已提交  （Oracle默认）
        事务A 开启
                                事务B 开启
                                读取该值 0
        修改该值为100                                 
                                读取该值 0
        提交事务commit
                                读取该值 100
                                结束事务
    
    3 可重复读  （MySQL默认）
        事务A 开启
                                事务B 开启
                                读取该值 0
        修改该值为100                                
                                读取该值 0
        提交事务commit
                                读取该值 0
                                结束事务
                                                事务C 开启
                                                读取该值 100
                                                结束事务
    4 串行化   
        相当于单线程 ，服务器上同一时刻只有一个事务在跑
    
        事务A 开启
        修改该值为100    
        提交事务commit            
                                事务B 开启
                                读取到 100
                                结束事务

## 2.24 事务的控制
    在事务的过程中可以使用 : savepoint  保存点名字 创建一些保存点
    
    下次如果发现之前某一步做错了，不至于直接 rollback回到原始事务开始的地方
    可以：rollback to savepoint 保存点名字
    
    一旦当前事务提交或者回滚，在当前事务建立的savepoint将失效

## 2.25 习题

### 1. 子查询和行号

```sql
-- 【第一题】：找到员工表中工资最高的前三名， 要求按如下格式输出
-- 补充知识：rownum 行号(伪列)   
    select rownum , emp.* 
    from emp 
-- 在结果中看到行号，行号是筛选数据的过程中自动生成的，并不真正存在于表中

    select rownum , ename, sal 
    from emp
    order by sal desc -- 问题是如何取出前三行
--  行号是乱的，工资的降序是对的
--  结论：行号在排序前已经生成好了

--  解决思路：
--      1.先排序，
--      2.再生成行号 
--      3.再筛选 行号 < 3
--  1.子查询先排序，
--  2.父查询生成行号
--  3.父查询最后进行一次筛选
    select rownum, e.*
    from 
        (
            select empno,ename,sal
            from emp
            order by sal desc 
            -- 一般不在子查询中使用order by，但在Top-N问题中，必须使用order by
        ) e
    where rownum <=3



--  延伸的问题： 分页问题，按照工资降序排序，取5-8 名 
--      也是依赖行号
--      rownum不能直接用 > 来比较  ，除了 >=1 
--  	与行号的生成逻辑有关
--  	行号生成在where条件判断的时候
--
--  where rownum <=3
--      1      king          where 1<=3 为真   通过筛选
--      2      ford          where 2<=3 为真   通过筛选
--      ...
--
--  where rownum >=5
--      1      king          where 1>=5 为假   没通过筛选
--      1      ford          where 1>=5 为假   没通过筛选
--      ...
--          因为king没有通过筛选，1号的行号保留
--
--  (分页问题的解决)先让行号固定下来，不要筛选的时候再生成
    select *
    from 
    (
        select rownum r, e.*
        from 
        (
            select empno,ename,sal
            from emp
            order by sal desc
        ) e
    )
    where r >=5 and r <=8
```

### 2.自连接和关联子查询

```sql
--【第二题提示】：找到emp表中薪水大于本部门平均薪水的员工
--    empno ename sal avgsal
--	  多表查询   ,自行构造另一张表 
--    from 后置子查询

--1 查询每个部门的平均工资
    select deptno,avg(sal)
    from emp
    group by deptno 

--2 用以上的结果和emp表，进行多表连接
    select *
    from emp a,
    (
        select deptno,avg(sal) avg_sal
        from emp
        group by deptno 
    ) b
    where a.deptno = b.deptno and a.sal > b.avg_sal

--关联子查询 更适合用来解决这道题！！！
```

#### 关联子查询

```sql
--关联子查询
--    子查询不能独立的执行，必须依赖父查询

    select *
    from emp outer
    where sal > (
        --查询出该员工所在部门的平均工资
        select avg(sal)
        from emp inner
        where inner.deptno = outer.deptno
    )

--    一般先执行子查询（内查询），再执行父查询（外查询）；关联子查询除外
--    关联子查询原理，每次父查询迭代，都会执行一次子查询
--    例子：
--        allen   部门号 30
--        执行子查询 ,查询出30号部门的平均工资
--            select avg(sal) from emp where deptno = 30
--        最后再通过父查询的where条件来判断
--
--        jones   部门号是20
--        执行子查询，查询出20号部门的平均工资
--			select avg(sal) from emp where deptno = 20
--        ...
--
--        结论：
--            关联子查询中，where条件迭代多少次，子查询就执行多少次，导致效率不高
--
--            慎用关联子查询！！！！
```

### 3. 01标记法

```sql
--【第三题提示】：统计每年入职的员工个数
--    1980 1
--    1981 2 
--    .....
    select hire_year,count(*)
    from 
    (
        select to_char(hiredate,'yyyy') hire_year
        from emp
    )
    group by hire_year

--    1980 1
--    1981 2 
--    .....
```

```sql
-- 思路一可以使用01 标记法（依赖 条件语句）
--             1980   1981   1982  ....
--     1980      1      0      0
--     1981      0      1
--     1981      0      1
--     1981
--     1981
--     1981
--     1981
--     1987
--     1981
--     1981
--     1987
--     1981
--     1981
--     1982
select  
        count(*) total,
        sum("year_1980") "1980",
        sum("year_1981") "1981",
        sum("year_1982") "1982",
        sum("year_1987") "1987"
from 
    (
        select hire_year,
            decode(hire_year,'1980',1,0) "year_1980",
            decode(hire_year,'1981',1,0) "year_1981",
            decode(hire_year,'1982',1,0) "year_1982",
            decode(hire_year,'1987',1,0) "year_1987"
        from 
            (
                select to_char(hiredate,'yyyy') hire_year
                from emp
            )
    )
```

 ## 2.26 oracle表操作

### 1.创建表

```sql
--    create table 表名
--    (
--        列名1 类型1,
--        列名2 类型2,
--        .....
--    )
    
    
    
--另一种创建表的方式
--    创建一张表emp2，数据跟emp表一样
        create table emp2 
        as 
        select * from emp
```


```sql
--创建一个员工表t1：员工号id（整数），和姓名name（字符串）
   create table t1
   (
       id number,
       name varchar2(30)
   )
   sql 标准：varchar  可变长的字符串
   oracle 自身拓展了一下：varchar2
       
--char    定长的字符串
--char(30)：跟C中char[30]差不多，定长，不管存储什么数据，就固定占用30个字符空间
--varchar(30)：最多也只能存储30个字符的空间，但是如果只存储hello，只会占用约5个字符空间
--char查询性能是要高于varchar，明确数据的长度就是固定的，可以直接用char
--例子：身份证号18位   



--    创建一张表emp3，数据跟emp表一样，只有表结构，没有数据
        create table emp3 
        as select * from emp;
        delete from emp3;
        
        create table emp4 
        as 
            select * 
            from emp 
            where 1=2 -- 恒为假，所以数据不会拷贝过去
```

### 2.修改表

```sql
    alter table tableName xxxxx

--    1 往t1表里边添加一列 email varchar(40)
        alter table t1 add email varchar(40)
        
--    2 修改t1表email列名为address
        alter table t1 rename column email to address
        
--    3 修改t1表address列的类型为varchar(50)
        alter table t1 modify address varchar(50)
        
--    4 删除t1表address列
        alter table t1 drop column address
        
--    5 修改t1表名为t2
        rename t1 to t2
```

### 3.清空表      

```sql
    delete from 表名 
    
    truncate table t1 
```

    1.  delete 逐条删除表“内容”，
        truncate 先摧毁表再重建。 
        (由于delete使用频繁，Oracle对delete优化后delete快于truncate)
        
    2.  delete 是DML语句，truncate 是DDL语句。
        DML语句可以闪回(flashback)和回滚rollback，
        DDL语句不可以闪回和回滚。
        （闪回：做错了一个操作并且commit了，对应的撤销行为。了解）
        
    3.  由于delete是逐条操作数据，所以delete会产生碎片，
        truncate不会产生碎片。
        （同样是由于Oracle对delete进行了优化，让delete不产生碎片）。
        两个数据之间的数据被删除，删除的数据——碎片，整理碎片，数据连续，行移动。
        
    4.  delete不会释放空间，
        truncate 会释放空间。
        用delete删除一张10M的表，空间不会释放。
        而truncate会。
        所以当确定表不再使用，应使用truncate。

### 4.删除表            

        drop table 表名
            oracle提供了回收站机制，删表的时候先移动到回收站
    
        purge table 表名
            从回收站中彻底删除某张表
    
        drop table 表名 purge
            彻底删除表，不移动到回收站
    
        oracle 提供一个闪回的技术，能够将表还原到以前的某个时间点
            flashback table 表名 to before drop
    
        show recyclebin
        purge recyclebin 
            清空回收站

### 5. 表的约束

```
    1 非空
        not null
        
    2 唯一
        unique

    3 检查
        check
        
    4 主键
        primary key
        一个表中只能有一个主键(一列或者多列组合而成)
		主键约束隐含：not null + unique
	5 外键
    	foreign key
        一张表的某一列（或多列）参照另一张表的某一列（或多列）
        在这张表填入的数据必须要在另一张表中能够找到，或者为null
        涉及的问题：父表的数据删除(更新）了子表数据怎么办
            1 不允许父表执行删除
            2 父表删除数据之后，子表对应的数据全部设置为null
            3 父表删除数据之后，子表对应的数据也跟着删除，级联删除
        
```

 


```sql
-- create table 表名
-- (
-- 	   列名1 类型1 [constraint 约束名 约束类型] constraint 约束名2 约束类型2 ..,
--     列名2 类型2 [constraint 约束名 约束类型] ...  ,
--     ....
-- )  

create table student 
(
    sid number constraint pk_student primary key, --学生Id主键约束
    sname varchar2(20) constraint nn_student_name not null,--学生姓名非空约束
    email varchar2(20) constraint un_student_email unique --学生邮件唯一约束
    constraint nn_student_email not null,   --同时邮件可再设非空，没有“，”
    age number constraint chk_student_age_min check(age > 10),  --学生年龄设置check约束
    gender varchar2(6) constraint chk_student_gender check(gender in ('男', '女')),
    deptno number constraint fk_student references dept (deptno) ON DELETE SET NULL 
    -- references dept (deptno) -- 外键约束(参照dept表中的deptno列)
    -- ON DELETE SET NULL -- 父表对应的列删除，子表对应的列值设置为空
) 


--可以查看指定表（如 student）的约束，注意表名必须大写。 
select 
	constraint_name, 
	constraint_Type, 
	search_condition      
from user_constraints 
where table_name='STUDENT' 
```

## 2.27 视图

    视图提供的目的就是为了简化查询
    
    视图的优点                      
        1. 简化复杂查询： 
            原来分组、多表、子查询等可以用一条 select * from xxxview 代替。      
            视图可以看做是表的复杂的 SQL 一种封装。 
        2. 限制数据访问： 
            只看视图的结构和数据是无法清楚视图是怎样得来的。
            可以限制数据的访问。 
            例如： 银行项目，所谓的各个“表”都是“视图”，并有可能只是“只读视图” 
    注意： 
    	1. 视图不能提高性能 
        2. 不建议通过视图对表进行修改。 
    
    
    create view 视图名称
    as
        子查询
        
    要注意，创建视图需要权限，需要oracle管理员对scott赋予权限
        在centos 上 使用 sqlplus / as sysdba
        grant create view to scott 
    
    删除视图
        drop view 视图名


    创一个视图，用来观看10号部门的员工信息
        create view v_emp_10
        as 
            select * 
            from emp 
            where deptno = 10
    
        create table t_emp_10
        as 
            select * 
            from emp 
            where deptno = 10
    
        视图是不存在数据，只是一个查询语句的结果
        每次执行 select 去查看视图的时候，都会执行视图的sql语句
        视图其实也是一条查询sql语句的封装 

## 2.28 序列
    创建一张表
        create table t1
        (
            id number primary key,
            name varchar2(30) not null
        )
    插入数据
    	insert into t1 values(1,'name-1')
    	insert into t1 values(2,'name-2')
    人工去记住这个idd递增，不靠谱，让计算机自身去记住这个id，每次自增
    
    
    创建序列：create sequence sequenceName
    删除序列：drop sequence sequenceName
        currval
            当前的序列的值
                select myseq.currval from dual
                    第 1 行出现错误:
                    ORA-08002: 序列 MYSEQ.CURRVAL 尚未在此会话中定义
                    注意：获取currval 不能早于第一次获取nextval
        nextval
            从序列获取下一个值
            	select myseq.nextval from dual
            注意：每次sql执行，nextval只会获取一次值
                (一条SQL语句中多次使用nextval，但是取到的是相同的值，因为只获取一次值)
    
    使用序列进行插入数据
    	insert into t1 values(sequenceName.nextval,'name-'||sequenceName.nextval)
    	insert into t1 values(sequenceName.nextval,'name-'||sequenceName.nextval)
    	...

## 2.29 索引



        原理，对数据某一列（或者多列）进行排序，将排序号的数据以及对应的行地址
        存起来，下次查询数据的时候先查询索引，然后再提取数据
        
    创建索引    
    	create index 索引名 on 表名(列名)
    	create index 索引名 on 表名(列名1,列名2 ....)
    删除索引 
    	drop index 索引名字
    	
    	
    create index inx_emp_deptno on emp(deptno)
    
    索引创建完成之后，不用我们去管，正常做查询，数据库自动判断我们查询条件
    有没有用到索引，有用到就自动使用
    
    什么情况下用到索引
        create index inx_emp_deptno on emp(deptno)
        where deptno = 10


        create index idx2 on emp(deptno,job)   复合索引
            where job = 'CLERK'   有没有用到索引？  -- 没有用到索引
            where deptno>10 and job = 'xxxx'    使用到了索引


    

## 同义词

    为hr.employees表创建同义词
        create synonym 别名 for 某数据库对象
        create synonym hremp for hr.employees;
    
    删除同义词
        drop synonym 别名



# 3.mysql

## 3.1 登录mysql


```sql
--直接在shell环境中 使用以下命令
	mysql -u用户名 -p密码
	mysql -uroot -proo123

--其中root是用户名，该用户跟linux中的root不是同一个用户
--mysql有自己的账号体系，其中的数据库管理员也叫root
```



    oracle 账号体系,一个用户对应一个方案，用户名就是方案名
    在mysql中一个用户是可以拥有多个方案
    
    show databases|schemas  
        查看当前用户拥有哪些数据库（方案）
    
    use databaseName
        切换到某个数据库进行操作
    
    show tables 
        查看当前该数据库中有什么表


    结论：
        mysql账号体系比oracle要多一层，要操作方案（数据库）
        
    Oracle一个用户对应一个方案(数据库 database)；该方案下有多张表(table)
    MySQL一个用户用多个方案(数据库 database)；每个方案下都有多张表(table)

## 3.2 库操作

```sql
--创建数据库d1 并指定默认字符集为UTF8
create database d1 
default charset= 'UTF8';
```

```sql
--查看创库语句
show create database d1;
```


```sql
--删库
drop database 库名
```

## 3.3 表操作

- 创建表

```sql
-- 创建表
--     t1
--     ( id 整形 
--       name 可变字符串30长度
--     )
create table t1
(
    id int,
    name varchar(30)
)
```

```sql
-- edit 命令可以打开编辑器，默认是使用vi
```

```sql
--desc 表名
--    查看表结构
```

- 修改表

```sql
--添加一列
-- 添加一列email varchar(30)
	alter table t1 add email varchar(30)

--修改列的属性
--修改name(姓名这列) 增加长度到40字符(修改属性)
    alter table t1 modify name varchar(40)

--修改列名，修改列的属性
--修改email 列重命名 到 address ，并且修改类型为 varchar(40)
    alter table t1 change email address varchar(40)
  
--显示创建该表的sql语句
	show create table t1;
--删除列
--删除列address
    alter table t1 drop column address

--修改表名
--修改表t1表名为T2，注意大小写
    rename table t1 to T2

--删除表T2
    drop table t2
```


```sql
--注意：mysql 表名等数据库对象名大小写敏感
```



​    