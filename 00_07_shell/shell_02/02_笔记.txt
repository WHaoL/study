1 输入输出
    输入 read
    echo [option] string
        -e 解析转义字符
        -n 不回车换行。默认情况echo回显的内容后面跟一个回车换行。
        echo "hello\n\n"
        echo -e "hello\n\n"
        echo "hello"

    printf 格式字符串  参数1 参数2 ..
        跟C语言的printf一致


2 管道
    pipe

    命令1 | 命令2 ....

        竖线的作用就是将前面进程的标准输出重定向到后面进程的标准输入  ( 正常标准错误输出是不会重定向 )


    more
        提供对文本的滚动操作
        回车单行滚动，空格翻页

    less 命令
        也跟more差不多，支持更多类似于vim的操作，能够进行查找，回滚...


3 tee命令
    
    命令 | tee [-a] 文件名
    
    读取标准输入的内容，也原样输出到标准输出，同时存一份到文件

        运行游戏服务器，日志一下就刷屏，使用tee命令，来进行跟踪，同时将日志存到一个文件里边，如果
        错过了什么重要的日志可以查看文件

        -a 
            以追加的方式来打开文件，默认是直接覆盖

4 文件重定向
    cmd > file              把标准输出重定向到新文件中
    cmd >> file             追加
    cmd >file 2>file2

        0 标准输入
        1 标注输出
        2 标准错误输出

         标准输出重定向到file 标准错误输出重定向到file2


    cmd > file 2>&1         标准出错也重定向到1所指向的file里
        2>&1  文件描述符2也重定向到文件描述符1的位置
            标准错误输出也重定向到标准输出的位置

    cmd >> file 2>&1
    cmd < file1             输入定向到文件里
        将file1 读取处理扔到命令的标准输入
    cmd < &fd               把文件描述符fd作为标准输入
        很少用
    cmd > &fd               把文件描述符fd作为标准输出

    cmd < &-                关闭标准输入

5 函数

    function 函数名()    #括号中没有形参列表
    {
        xxxxxxx
        local var=xxx      #局部变量
        return 0
    }


    函数的定义中function 或者小括号 最多只能省一个

    local 定义局部变量

    return 只能返回整数，作为该函数的退出状态 
        如果没有return语句，函数默认的退出状态就是最后一条命令执行的退出状态
        如果想返回字符串，就使用命令代换的形式来获取返回值


    函数的调用，当做一个普通命令来调用
        函数名  参数1 参数2 参数3 ....

        函数中通过$1 $2.. 来获取函数的参数


    函数支持递归
        需求：遍历当前目录的所有文件，是普通文件就 xxx is a file
                是目录 就输出 xxx is a directory
            还要同时遍历子目录中的文件

6 shell脚本的调试方法

    -n 读一遍脚本，但是不执行，只是查看语法错误
    -v 一边执行一遍输出读到的脚本
    -x 最常用的 ，执行的过程中输出执行的语句，包括变量的值也会输出出来
        输出的信息 + 表示调试信息，如果有多个++ 表示开启了子进程


    启动调试的方法
        1 bash -x test.sh

        2 在脚本的第一句话开启  #!/bin/bash -x

        3 在脚本运行的过程中
            set -x   #开启调试
                .....  一段代码
            set +x   #关闭调试

7 正则表达式
练习:

    1 以S开头的字符串
        ^S

        使用^表示字符串的开头匹配

    2 以数字结尾的字符串
        匹配一个数字
            [0123456789]        将所有数字枚举出来，使用中括号括起来表示匹配其中字符的一次出现
            [0-9]               同上，是一个区间的形式
            \d                  同上
        匹配字符串结束 $

        [0-9]$

    3 匹配空字符串(没有任何字符)
        ^$


    4 字符串只包含三个数字
        ^\d\d\d$

        ^[0-9]{3}$

            {n} 表示前面的单元重复n次


    5 字符串只有3到5个字母
        {m,n}   m表示前面单元最少重复次数，n表示最多重复次数

        匹配字母
        [a-zA-Z]    多个区间之间不要留空格

        ^[a-zA-Z]{3,5}$


    6 匹配不是a-z的任意字符
        [^a-z]   中括号中第一个字符是^，表示区间取反


    7 字符串有0到1个数字或者字母或者下划线
        [0-9a-zA-Z_]
            \w      同上
        ^\w{0,1}$
        ^\w?$
            ? 表示前面的单元重复 0-1次 等同于 {0,1}


    8 字符串有1个或多个空白符号(\t\n\r等)
        \s   代替这些空白字符 

        ^\s{1,}$

        ^\s+$
            + 等同于 {1,}  ,表示前面的单元重复1-n次


    9 字符串有0个或者若干个任意字符(除了\n)
        .   表示除了\n 的任意字符

        ^.*$

            * 表示前面的单元重复0-n次


        ?    0-1
        +    1-n
        *    0-n



    10 匹配0或任意多组ABC，比如ABC，ABCABCABC

        将ABC组合成为一个单元,使用小括号

        ^(ABC)*$


    11 字符串要么是ABC，要么是123
        选择关系使用 | ，表示左右两边的正则做选择

        ^ABC|123$
            这样写就会变成要么ABC开头，要么123结束

        ^ABC$|^123$
        ^(ABC|123)$       小括号能够限制竖线选择范围


    12 字符串只有一个点号
        ^.$   错误
        .号是特殊字符，要考虑转义 , 还是使用\

        ^\.$


    13 匹配十进制3位整数
        100-999

        ^[1-9][0-9][0-9]$


        0-999       排除011这类
            分段
            1位数
                ^[0-9]$
            2位数
                10-99
                ^[1-9][0-9]$

            将以上3段连在一起，做选择
            ^([0-9]|[1-9][0-9]{1,2})$



    14 匹配0-255的整数
        常用于匹配用户输入的ip地址
        分段
            1位数
                ^[0-9]$
            2位数
                10-99
                ^[1-9][0-9]$

            3位数
                100-255

                继续分段
                    100-199
                        1[0-9]{2}

                    200-249
                        2[0-4][0-9]

                    250-255
                        25[0-5]

        匹配端口号 0-65535

8 正则的分类


    基础正则 basic
        ?+{}|()   是普通字符

    扩展的正则 extended
        ?+{}|()  是特殊字符

    perl正则 
        目前我们学习的，也是编程中最常用
        建立在扩展正则之上，添加了一堆特殊字符
            \s \d \w ....

9 sort
    命令从标准输入中读取数据然后按照字符串内容进行排序
        -f 忽略字符大小写
        -n 比较数值大小
        -t 指定分割符，默认是空格或者tab
        -k 指定分割后进行比较字段
        -u 重复的行只显示一次
        -r 反向排序
        -R 打乱顺序

    sort -t: -n -k3 < /etc/passwd    

10 uniq
    去除重复的行,前提是重复的行连续
    -c 显示每行重复的次数
    -d 仅显示重复过的行
    -u 仅显示不曾重复的行
        sort < test.txt | uniq

11 wc
    word countter

    -l 统计行数
    -c 统计字节数
    -w 统计单词数

    wc -l *.cpp 
        计算代码行数


12 grep
    global regular expression print
    egrep = grep -E
    fgrep = grep -F
    rgrep = grep -r


    -c 只输出匹配行的计数
    -i 不区分大小写
    -H 文件名显示
    -n 显示行号
    -s 不显示不存在或无匹配文本的错误信息
    -v 显示不包含匹配文本的所有行，这个参数经常用于过滤不想显示的行
        反选
    -E 使用扩展的正则表达
        grep正常情况下是使用basic正则

    -P 使用perl的正则表达式

    -F 固定字符串匹配，不会将字符串当做正则表达式来解析

    -r 递归
        同时搜索目录



13 find
    find pathname -options [-print -exec -ok ...]
        find . -name "aaa"

    pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录，递归查找。
    -print： find命令将匹配的文件输出到标准输出。
    -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {} \;
            注意{}内部无空格，和\；之间含有一个空格分隔符。

        find . -name "*.txt" -exec mv {} {}.png \;
            查找当前目录的txt文件，然后将txt文件添加一个后缀.png

            -exec 就是每次找到文件之后要执行什么命令
                mv {} {}.png        这里的花括号是会被找到的文件名替换的
                mv 6.txt 6.txt.png    
                \; 表示该命令的结束 反斜杠不能省略


    -ok： 和-exec的作用相同，
           只不过以一种更为安全的模式来执行该参数所给出的shell命令，
           在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
           只有用户明确输入y才会执行后边的语句


    -name 按照文件名查找文件。
    -perm 按照文件权限来查找文件。
        find . -perm 777

    -user 按照文件属主来查找文件。
    -group 按照文件所属的组来查找文件。
    -mtime -n +n 按照文件的更改时间来查找文件，-n表示文件更改时间距现在n天以内，
        +n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。

    -nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。
    -nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。
    -newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。


    -type 查找某一类型的文件，诸如：
        b - 块设备文件。
        d - 目录。
        c - 字符设备文件。
        p - 管道文件。
        l - 符号链接文件。
        f - 普通文件。
        s - socket 文件

    -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。
    -depth 在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
    -fstype 查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配
    置文件中包含了本系统中有关文件系统的信息。
    -mount 在查找文件时不跨越文件系统mount点。
    -follow 如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。



14 xargs

    主要作用就是将标准输入读取到的参数排成一行
    主要是配合其他命令来使用
        test.txt 里边有 aa bb
    cat test.txt | xargs touch 

        最终xargs会将 aa bb 两个参数排成一行，跟到touch后面
            touch aa bb


        docker ps -aq | xargs docker rm -f 
            删除所有的docker容器

    xargs 可以指定替换字符串

    find . -name "*.txt" | xargs -I{} mv {} b

        -I{}  表示指定替换字符串是{}   之前标准输入的内容的参数将会替换后面命令的{}


15 sed
    文件内容 ->  sed + 脚本  ->  文件内容2 
    sed option 'script' file1 file2 ...             sed 参数  ‘脚本(/pattern/action)’ 待处理文件
    sed option -f scriptfile file1 file2 ...        sed 参数 –f ‘脚本文件’ 待处理文件

        p,  print           打印
        a,  append          追加
        i,  insert          插入
        d,  delete          删除
        s,  substitution    替换


        sed '2d' test.txt
            删除第二行的内容

        /pattern/action    符合某个模式就执行什么动作

        sed -n '/123/p' test.txt   只要该行有123的就输出，其他不管

        sed 's/<[a-zA-Z/]*>//g' testfile 
            将html内容中的标签全部干掉

16 awk
    awk是一个命令，也是一个脚本语言

    awk option 'script' file1 file2 ...
    awk option -f scriptfile file1 file2 ...


    awk -F: '{print $1}'   /etc/passwd

        提取passwd 文件的第一列 ，以:作为分隔符   注意其中脚本要使用单引号
        因为双引号还支持变量扩展

    脚本的语法内容
    {actions}
        每一行文本都无条件的执行某些动作
    /pattern/{actions}
        该行文本匹配了模式，就执行某些动作
    condition{actions}
        只要满足某个条件就执行某些动作
        有两个特殊条件

        BEGIN{actions} 在遍历文本第一行之前会执行的动
        END{actions}   在遍历文本最后一行之后会执行的动作



    ProductA 30
    ProductB 76
    ProductC 55

    如果库存量少于75 提示要重新订货
        $2<75 {
            print $1,$2,"reorder";
        }
        $2>=75 {
            print $1,$2;
        }

    使用BEGIN 和 END，实现：输出列名  产品名 + 库存量    ，输出结果要显示库存总量

        BEGIN{
            #输出表头
            printf("产品名\t库名\n");

            #定义一个变量，存储库存总量
            sum=0;
        }
        $2<75 {
            print $1,$2,"reorder";
        }
        $2>=75 {
            print $1,$2;
        }
        {
            sum+=$2;
        }
        END{
            printf("库存总量:%d\n",sum);
        }

    awk是比较强大的工具，能够做一些数理统计等操作....










crontab
